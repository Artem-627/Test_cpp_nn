/ *
LodePNG версия 20210627

Авторские права(c) 2005 - 2021 Lode Vandevenne

Это программное обеспечение предоставляется «как есть», без каких - либо явных или подразумеваемых
гарантия.Ни в коем случае авторы не несут ответственности за любой ущерб.
возникшие в результате использования этого программного обеспечения.

Всем предоставляется разрешение на использование этого программного обеспечения в любых целях,
включая коммерческие приложения, а также изменять и распространять его
свободно, со следующими ограничениями :

1. Запрещается искажать происхождение этого программного обеспечения; ты не должен
утверждают, что вы написали оригинальное программное обеспечение.Если вы используете это программное обеспечение
в продукте подтверждение в документации по продукту будет
приветствуется, но не требуется.

2. Измененные исходные версии должны быть четко обозначены как таковые и не должны
ошибочно представлен как оригинальное программное обеспечение.

3. Это уведомление не может быть удалено или изменено из любого источника.
распределение.
* /

#ifndef LODEPNG_H
#define LODEPNG_H

#include <string.h> / * для size_t * /

extern const char* LODEPNG_VERSION_STRING;

/ *
Следующие #defines используются для создания разделов кода.Их можно отключить
чтобы отключить разделы кода, что может ускорить компиляцию и уменьшить размер двоичного файла.
Определения "NO_COMPILE" предназначены для использования в качестве определений в
команда компилятора, чтобы отключить их без изменения этого заголовка, например
- DLODEPNG_NO_COMPILE_ZLIB для gcc.
В дополнение к приведенным ниже, вы также можете определить LODEPNG_NO_COMPILE_CRC для
позволяют реализовать собственный lodepng_crc32.
* /
/ *deflate & zlib.Если отключено, вы должны указать альтернативные функции zlib в
поле custom_zlib настроек сжатия и распаковки* /
#ifndef LODEPNG_NO_COMPILE_ZLIB
#define LODEPNG_COMPILE_ZLIB
#endif

/ *кодировщик png и декодер png * /
#ifndef LODEPNG_NO_COMPILE_PNG
#define LODEPNG_COMPILE_PNG
#endif

/ *deflate и декодер zlib и декодер png * /
#ifndef LODEPNG_NO_COMPILE_DECODER
#define LODEPNG_COMPILE_DECODER
#endif

/ *deflate & кодировщик zlib и кодировщик png * /
#ifndef LODEPNG_NO_COMPILE_ENCODER
#define LODEPNG_COMPILE_ENCODER
#endif

/ *дополнительные встроенные функции загрузки и сохранения файлов с жесткого диска * /
#ifndef LODEPNG_NO_COMPILE_DISK
#define LODEPNG_COMPILE_DISK
#endif

/ *поддержка блоков, отличных от IHDR, IDAT, PLTE, tRNS, IEND: вспомогательные и неизвестные блоки* /
#ifndef LODEPNG_NO_COMPILE_ANCILLARY_CHUNKS
#define LODEPNG_COMPILE_ANCILLARY_CHUNKS
#endif

/ *возможность конвертировать числовые коды ошибок в текстовую строку на английском языке * /
#ifndef LODEPNG_NO_COMPILE_ERROR_TEXT
#define LODEPNG_COMPILE_ERROR_TEXT
#endif

/ *Компилируем распределители по умолчанию(C's free, malloc и realloc). Если вы отключите это,
    вы можете определить функции lodepng_free, lodepng_malloc и lodepng_realloc в своем
    исходные файлы с настраиваемыми распределителями. * /
#ifndef LODEPNG_NO_COMPILE_ALLOCATORS
#define LODEPNG_COMPILE_ALLOCATORS
#endif

    / *компилируем версию C++ (здесь можно отключить оболочку C ++ даже при компиляции для C++) * /
#ifdef __cplusplus
#ifndef LODEPNG_NO_COMPILE_CPP
#define LODEPNG_COMPILE_CPP
#endif
#endif

#ifdef LODEPNG_COMPILE_CPP
#include <вектор>
#include <строка>
#endif / * LODEPNG_COMPILE_CPP * /

#ifdef LODEPNG_COMPILE_PNG
    / *Цветовые типы PNG(также используются для необработанных изображений). * /
    typedef enum LodePNGColorType {
    LCT_GREY = 0, / *оттенки серого : 1, 2, 4, 8, 16 бит * /
    LCT_RGB = 2, / *RGB : 8, 16 бит * /
    LCT_PALETTE = 3, / *палитра : 1, 2, 4, 8 бит * /
    LCT_GREY_ALPHA = 4, / *оттенки серого с альфа - каналом : 8, 16 бит * /
    LCT_RGBA = 6, / *RGB с альфа - каналом : 8, 16 бит * /
    / *LCT_MAX_OCTET_VALUE позволяет компилятору разрешить этому перечислению представлять любые недопустимые
    байтовое значение от 0 до 255, которое могло присутствовать в недопустимом заголовке файла PNG.Делать
    не использовать, сравнивать или устанавливать имя LCT_MAX_OCTET_VALUE, вместо этого либо используйте
    допустимые имена типов цвета выше или числовые значения, такие как 1 или 7, при проверке
    определенные запрещенные значения байтов цветового типа или приведение к целому числу для его печати.​​* /
    LCT_MAX_OCTET_VALUE = 255
} LodePNGColorType;

#ifdef LODEPNG_COMPILE_DECODER
/ *
Преобразует данные PNG в памяти в необработанные данные пикселей.
out: выходной параметр.Указатель на буфер, который будет содержать необработанные данные пикселей.
После декодирования его размер w* h* (байтов на пиксель) байтов больше, чем
изначально.Количество байтов на пиксель зависит от типа цвета и глубины цвета.
Должен быть освобожден после использования с помощью free(*out).
Примечание : для 16 - битных цветов на канал используется формат с прямым порядком байтов, как в PNG.
w : выходной параметр.Указатель на ширину пиксельных данных.
h : выходной параметр.Указатель на высоту пиксельных данных.
in : буфер памяти с файлом PNG.
insize : размер в буфере.
colortype : желаемый тип цвета для необработанного выходного изображения.См.Пояснение к цветовым типам PNG.
bitdepth : желаемая битовая глубина для необработанного выходного изображения.См.Пояснения к цветовым типам PNG.
Возвращаемое значение : код ошибки LodePNG(0 означает отсутствие ошибки).
* /
беззнаковый lodepng_decode_memory(unsigned char** out, unsigned* w, unsigned* h,
    const unsigned char* in, size_t insize,
    LodePNGColorType colortype, беззнаковая битовая глубина);

/ *То же, что и lodepng_decode_memory, но всегда декодируется в 32 - битное необработанное изображение RGBA * /
беззнаковый lodepng_decode32(беззнаковый символ * *out, беззнаковый * w, беззнаковый * h,
    const unsigned char* in, size_t insize);

/ *То же, что и lodepng_decode_memory, но всегда декодируется в 24 - битное необработанное изображение RGB * /
беззнаковый lodepng_decode24(беззнаковый символ * *out, беззнаковый * w, беззнаковый * h,
    const unsigned char* in, size_t insize);

#ifdef LODEPNG_COMPILE_DISK
/ *
Загрузить PNG с диска, из файла с заданным именем.
То же, что и другие функции декодирования, но вместо этого принимает в качестве входных данных имя файла.

ПРИМЕЧАНИЕ.Имена файлов с расширенными символами не поддерживаются, вы можете использовать внешний метод.
для обработки таких файлов и декодирования в памяти.* /
беззнаковый lodepng_decode_file(unsigned char** out, unsigned* w, unsigned* h,
    const char* имя файла,
    LodePNGColorType colortype, беззнаковая битовая глубина);

/ *То же, что и lodepng_decode_file, но всегда декодируется в 32 - битное необработанное изображение RGBA.

ПРИМЕЧАНИЕ.Имена файлов с расширенными символами не поддерживаются, вы можете использовать внешний метод.
для обработки таких файлов и декодирования в памяти.* /
беззнаковый lodepng_decode32_file(unsigned char** out, unsigned* w, unsigned* h,
    const char* filename);

/ *То же, что и lodepng_decode_file, но всегда декодируется в 24 - битное необработанное изображение RGB.

ПРИМЕЧАНИЕ.Имена файлов с расширенными символами не поддерживаются, вы можете использовать внешний метод.
для обработки таких файлов и декодирования в памяти.* /
беззнаковый lodepng_decode24_file(unsigned char** out, unsigned* w, unsigned* h,
    const char* filename);
#endif / * LODEPNG_COMPILE_DISK * /
#endif / * LODEPNG_COMPILE_DECODER * /


#ifdef LODEPNG_COMPILE_ENCODER
/ *
Преобразует необработанные пиксельные данные в изображение PNG в памяти.Цветовой тип и битовая глубина
выходного изображения PNG нельзя выбрать, они определяются автоматически
по типу цвета, глубине цвета и содержанию входных данных пикселей.
Примечание: для 16 - битных цветов на канал требуется формат с прямым порядком байтов, как в PNG.
out : выходной параметр.Указатель на буфер, который будет содержать данные изображения PNG.
Должен быть освобожден после использования с помощью free(*out).
негабарит : Выходной параметр.Указатель на размер выходного буфера в байтах.
image : необработанные данные пикселей для кодирования.Размер этого буфера должен быть
w* h* (байтов на пиксель), байтов на пиксель зависит от цвета и глубины цвета.
w : ширина необработанных данных пикселей в пикселях.
h : высота необработанных данных пикселей в пикселях.
colortype : тип цвета необработанного входного изображения.См.Пояснения к цветовым типам PNG.
bitdepth : битовая глубина необработанного входного изображения.См.Пояснение к цветовым типам PNG.
Возвращаемое значение : код ошибки LodePNG(0 означает отсутствие ошибки).
* /
беззнаковый lodepng_encode_memory(unsigned char** out, size_t * outize,
    const беззнаковый символ * изображение, беззнаковый ш, беззнаковый ч,
    LodePNGColorType colortype, беззнаковая битовая глубина);

/ *То же, что и lodepng_encode_memory, но всегда кодируется из 32 - битного необработанного изображения RGBA. * /
беззнаковый lodepng_encode32(unsigned char** out, size_t * outize,
    const unsigned char* image, unsigned w, unsigned h);

/ *То же, что и lodepng_encode_memory, но всегда кодируется из 24 - битного необработанного изображения RGB. * /
беззнаковый lodepng_encode24(unsigned char** out, size_t * outize,
    const unsigned char* image, unsigned w, unsigned h);

#ifdef LODEPNG_COMPILE_DISK
/ *
Преобразует необработанные пиксельные данные в файл PNG на диске.
То же, что и другие функции кодирования, но вместо этого принимает в качестве вывода имя файла.

ПРИМЕЧАНИЕ.При этом существующие файлы будут перезаписаны без предупреждения!

ПРИМЕЧАНИЕ.Имена файлов с расширенными символами не поддерживаются, вы можете использовать внешний метод.
для обработки таких файлов и кодирования в памяти.* /
беззнаковый lodepng_encode_file(const char* filename,
    const беззнаковый символ * изображение, беззнаковый ш, беззнаковый ч,
    LodePNGColorType colortype, беззнаковая битовая глубина);

/ *То же, что и lodepng_encode_file, но всегда кодируется из 32 - битного необработанного изображения RGBA.

ПРИМЕЧАНИЕ.Имена файлов с расширенными символами не поддерживаются, вы можете использовать внешний метод.
для обработки таких файлов и кодирования в памяти.* /
беззнаковый lodepng_encode32_file(const char* filename,
    const unsigned char* image, unsigned w, unsigned h);

/ *То же, что и lodepng_encode_file, но всегда кодируется из 24 - битного необработанного изображения RGB.

ПРИМЕЧАНИЕ.Имена файлов с расширенными символами не поддерживаются, вы можете использовать внешний метод.
для обработки таких файлов и кодирования в памяти.* /
беззнаковый lodepng_encode24_file(const char* filename,
    const unsigned char* image, unsigned w, unsigned h);
#endif / * LODEPNG_COMPILE_DISK * /
#endif / * LODEPNG_COMPILE_ENCODER * /


#ifdef LODEPNG_COMPILE_CPP
namespace lodepng {
#ifdef LODEPNG_COMPILE_DECODER
    / *То же, что и lodepng_decode_memory, но декодируется в std::vector.Цветотип
        - это формат вывода пикселей.По умолчанию - RGBA 8 бит на канал. * /
        декодирование без знака(std::vector <unsigned char> &out, unsigned& w, unsigned& h,
            const unsigned char* in, size_t insize,
            LodePNGColorType colortype = LCT_RGBA, unsigned bitdepth = 8);
    декодирование без знака(std::vector <unsigned char>& out, unsigned& w, unsigned& h,
        const std::vector <unsigned char>& in,
        LodePNGColorType colortype = LCT_RGBA, unsigned bitdepth = 8);
#ifdef LODEPNG_COMPILE_DISK
    / *
        Преобразует файл PNG с диска в необработанные пиксельные данные в памяти.
        То же, что и другие функции декодирования, но вместо этого принимает в качестве входных данных имя файла.

        ПРИМЕЧАНИЕ.Имена файлов с расширенными символами не поддерживаются, вы можете использовать внешний метод.
        для обработки таких файлов и декодирования в памяти.
        * /
        декодирование без знака(std::vector <unsigned char> &out, unsigned& w, unsigned& h,
            const std::строка и имя файла,
            LodePNGColorType colortype = LCT_RGBA, unsigned bitdepth = 8);
#endif / * LODEPNG_COMPILE_DISK * /
#endif / * LODEPNG_COMPILE_DECODER * /

#ifdef LODEPNG_COMPILE_ENCODER
    / *То же, что и lodepng_encode_memory, но кодируется в std::vector.цветотип
        это исходные входные данные.Тип цвета выходного PNG будет выбран автоматически.* /
        кодирование без знака(std::vector <unsigned char> &out,
            const беззнаковый символ * in, беззнаковый w, беззнаковый h,
            LodePNGColorType colortype = LCT_RGBA, unsigned bitdepth = 8);
    кодирование без знака(std::vector <unsigned char>& out,
        const std::vector <unsigned char>& in, беззнаковый w, беззнаковый h,
        LodePNGColorType colortype = LCT_RGBA, unsigned bitdepth = 8);
#ifdef LODEPNG_COMPILE_DISK
    / *
        Преобразует 32 - битные необработанные пиксельные данные RGBA в файл PNG на диске.
        То же, что и другие функции кодирования, но вместо этого принимает в качестве вывода имя файла.

        ПРИМЕЧАНИЕ.При этом существующие файлы будут перезаписаны без предупреждения!

        ПРИМЕЧАНИЕ.Имена файлов с расширенными символами не поддерживаются, вы можете использовать внешний метод.
        для обработки таких файлов и декодирования в памяти.
        * /
        беззнаковое кодирование(const std::string & filename,
            const беззнаковый символ * in, беззнаковый w, беззнаковый h,
            LodePNGColorType colortype = LCT_RGBA, unsigned bitdepth = 8);
    беззнаковое кодирование(const std::string& filename,
        const std::vector <unsigned char>& in, беззнаковый w, беззнаковый h,
        LodePNGColorType colortype = LCT_RGBA, unsigned bitdepth = 8);
#endif / * LODEPNG_COMPILE_DISK * /
#endif / * LODEPNG_COMPILE_ENCODER * /
} / *пространство имен lodepng * /
#endif / * LODEPNG_COMPILE_CPP * /
#endif / * LODEPNG_COMPILE_PNG * /

#ifdef LODEPNG_COMPILE_ERROR_TEXT
/ *Возвращает описание числового кода ошибки на английском языке. * /
const char* lodepng_error_text(беззнаковый код);
#endif / * LODEPNG_COMPILE_ERROR_TEXT * /

#ifdef LODEPNG_COMPILE_DECODER
/ *Настройки для распаковки zlib * /
typedef struct LodePNGDecompressSettings LodePNGDecompressSettings;
struct LodePNGDecompressSettings {
    / *Проверьте LodePNGDecoderSettings на наличие более игнорируемых ошибок, таких как ignore_crc* /
        беззнаковый ignore_adler32; / *если 1, продолжить и не выдавать сообщение об ошибке, если контрольная сумма Adler32 повреждена* /
        беззнаковый ignore_nlen; / *игнорировать дополнение контрольной суммы len в несжатых блоках * /

        / *Максимальный размер распакованного изображения, сверх этого декодер может(и поощряется) остановить декодирование,
        вернуть ошибку, вывести размер данных > max_output_size и все данные до этого момента.Это
        не жесткое ограничение и не гарантия, но может предотвратить чрезмерное использование памяти.Этот параметр
        игнорируется декодером PNG, но используется декодером deflate / zlib и может использоваться пользовательскими.
        Установите 0, чтобы не накладывать ограничений(по умолчанию).* /
        size_t max_output_size;

    / *использовать собственный декодер zlib вместо встроенного(по умолчанию : null).
        Должен возвращать 0 в случае успеха, любое значение, отличное от 0, в случае ошибки(числовое значение не отображается).* /
        беззнаковый(*custom_zlib) (беззнаковый символ**, size_t*,
            const беззнаковый символ*, size_t,
            const LodePNGDecompressSettings*);
    / *использовать собственный декодер deflate вместо встроенного(по умолчанию : null)
        если custom_zlib не равен нулю, custom_inflate игнорируется(формат zlib использует deflate).
        Должен возвращать 0 в случае успеха, любое значение, отличное от 0, в случае ошибки(числовое значение не отображается).* /
        беззнаковый(*custom_inflate) (unsigned char**, size_t*,
            const беззнаковый символ*, size_t,
            const LodePNGDecompressSettings*);

    const void* custom_context; / *дополнительные пользовательские настройки для пользовательских функций * /
};

extern const LodePNGDecompressSettings lodepng_default_decompress_settings;
void lodepng_decompress_settings_init(настройки LodePNGDecompressSettings*);
#endif / * LODEPNG_COMPILE_DECODER * /

#ifdef LODEPNG_COMPILE_ENCODER
/ *
Настройки сжатия zlib.Изменение этих настроек приводит к изменению баланса
между скоростью и степенью сжатия.
* /
typedef struct LodePNGCompressSettings LodePNGCompressSettings;
struct LodePNGCompressSettings / *deflate = compress * / {
    / *Настройки, связанные с LZ77* /
        беззнаковый btype; / *тип блока для LZ(0, 1, 2 или 3, см.стандарт zlib).Должно быть 2 для правильного сжатия. * /
        беззнаковый use_lz77; / *следует ли использовать LZ77.Для правильного сжатия должно быть равно 1. * /
        беззнаковый размер окна; / *должно быть степенью двойки <= 32768. Более высокий сжимает больше, но медленнее.Значение по умолчанию : 2048. * /
        беззнаковый minmatch; / *минимальная длина lz77. 3 обычно лучше, 6 может быть лучше для некоторых PNG.По умолчанию : 0 * /
        беззнаковый nicematch; / *прекращаем поиск, если найдена > = эта длина.Установите 258 для наилучшего сжатия.По умолчанию : 128 * /
        беззнаковое ленивое сопоставление; / *использовать ленивое сопоставление : сжатие лучше, но немного медленнее.По умолчанию : true * /

        / *использовать собственный кодировщик zlib вместо встроенного(по умолчанию : null) * /
        беззнаковый(*custom_zlib) (беззнаковый символ**, size_t*,
            const беззнаковый символ*, size_t,
            const LodePNGCompressSettings*);
    / *использовать собственный кодировщик дефлятирования вместо встроенного(по умолчанию : null)
        если используется custom_zlib, custom_deflate игнорируется, поскольку только встроенный
        Функция zlib вызовет custom_deflate* /
        беззнаковый(*custom_deflate) (unsigned char**, size_t*,
            const беззнаковый символ*, size_t,
            const LodePNGCompressSettings*);

    const void* custom_context; / *дополнительные пользовательские настройки для пользовательских функций * /
};

extern const LodePNGCompressSettings lodepng_default_compress_settings;
void lodepng_compress_settings_init(настройки LodePNGCompressSettings*);
#endif / * LODEPNG_COMPILE_ENCODER * /

#ifdef LODEPNG_COMPILE_PNG
/ *
Цветовой режим изображения.Содержит всю информацию, необходимую для декодирования пикселя.
биты в цвета RGBA.Эта информация такая же, как и в файле PNG.
формат и используется как для PNG, так и для необработанных данных изображения в LodePNG.
* /
typedef struct LodePNGColorMode {
    / *заголовок(IHDR) * /
        LodePNGColorType colortype; / *тип цвета, см.стандарт PNG или документацию далее в этом заголовочном файле* /
        беззнаковая глубина бита; / *бит на образец, см.стандарт PNG или документацию далее в этом заголовочном файле* /

        / *
        палитра(PLTE и tRNS)

        Динамически выделяется цветами палитры, включая альфа.
        Это поле не может быть выделено напрямую, сначала используйте lodepng_color_mode_init,
        затем lodepng_palette_add для каждого цвета, чтобы правильно инициализировать его(чтобы обеспечить размер
            ровно 1024 байта).

        Альфа - каналы также должны быть установлены, установите для них 255 для непрозрачных изображений.

        При декодировании по умолчанию вы можете игнорировать эту палитру, поскольку LodePNG уже
        заполняет цвета палитры пикселями необработанного вывода RGBA.

        Палитра поддерживается только для цветового типа 3.
        * /
        беззнаковый символ * палитра; / *палитра в порядке RGBARGBA ... Должен быть либо 0, либо при выделении должен иметь 1024 байта * /
        size_t palettesize; / *размер палитры в количестве цветов(количество используемых байтов - 4 * размер палитры) * /

        / *
        прозрачный цветной ключ(tRNS)

        Этот цвет использует ту же битовую глубину, что и значение bitdepth в этой структуре, которое может быть от 1 до 16 бит.
        Для PNG с оттенками серого r, g и b все 3 будут установлены одинаковыми.

        При декодировании по умолчанию вы можете игнорировать эту информацию, поскольку LodePNG устанавливает
        пиксели с этим ключом для прозрачности уже в необработанном выходе RGBA.

        Цветовой ключ поддерживается только для типов цвета 0 и 2.
        * /
        беззнаковый key_defined; / *задан ли прозрачный цветовой ключ ? 0 = ложь, 1 = правда * /
        беззнаковый key_r; / *красный / полутоновый компонент цветового ключа * /
        беззнаковый key_g; / *зеленый компонент цветового ключа * /
        беззнаковый key_b; / *синий компонент цветового ключа * /
} LodePNGColorMode;

/ *функции инициализации, очистки и копирования для использования с этой структурой* /
void lodepng_color_mode_init(LodePNGColorMode * информация);
void lodepng_color_mode_cleanup(LodePNGColorMode* информация);
/ *возвращаемое значение - код ошибки(0 означает отсутствие ошибки) * /
беззнаковый lodepng_color_mode_copy(LodePNGColorMode * dest, const LodePNGColorMode * source);
/ *Делает временный LodePNGColorMode, который не требует очистки(без палитры)* /
LodePNGColorMode lodepng_color_mode_make(LodePNGColorType colortype, беззнаковая битовая глубина);

void lodepng_palette_clear(LodePNGColorMode* информация);
/ *добавляем в палитру 1 цвет * /
беззнаковый lodepng_palette_add(информация о LodePNGColorMode*,
    символ без знака r, символ без знака g, символ без знака b, символ без знака a);

/ *получаем общее количество бит на пиксель в зависимости от типа цвета и глубины цвета в структуре * /
беззнаковый lodepng_get_bpp(const LodePNGColorMode * info);
/ *получаем количество используемых цветовых каналов в зависимости от типа цвета в структуре.
Если используется палитра, она считается 1 каналом. * /
беззнаковый lodepng_get_channels(const LodePNGColorMode * info);
/ *это оттенки серого ? (только цветотип 0 или 4) * /
беззнаковый lodepng_is_greyscale_type(const LodePNGColorMode * info);
/ *есть ли у него альфа - канал ? (только цветотип 2 или 6) * /
беззнаковый lodepng_is_alpha_type(const LodePNGColorMode * info);
/ *есть палитра ? (только цветотип 3) * /
беззнаковый lodepng_is_palette_type(const LodePNGColorMode * info);
/ *возвращает истину только в том случае, если есть палитра и есть значение в палитре с альфа < 255.
    Просмотрите палитру, чтобы проверить это.* /
    беззнаковый lodepng_has_palette_alpha(const LodePNGColorMode * info);
/ *
Проверьте, указывает ли данная информация о цвете возможность наличия непрозрачных пикселей в PNG - изображении.
Возвращает true, если изображение может иметь полупрозрачные или невидимые пиксели(оно все равно будет непрозрачным, если оно не использует такие пиксели).
Возвращает false, если изображение может иметь только непрозрачные пиксели.
В деталях, он возвращает true, только если это цветовой тип с альфа - каналом или палитра с непрозрачными значениями,
или если "key_defined" истинно.
* /
беззнаковый lodepng_can_have_alpha(const LodePNGColorMode * info);
/ *Возвращает размер в байтах буфера необработанного изображения с заданной шириной, высотой и цветовым режимом* /
size_t lodepng_get_raw_size(беззнаковый w, беззнаковый h, const LodePNGColorMode * цвет);

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/ *Информация о временном фрагменте в PNG. * /
typedef struct LodePNGTime {
    беззнаковый год; / *Использовано 2 байта(0 - 65535) * /
        беззнаковый месяц; / *1 - 12 * /
        беззнаковый день; / *1 - 31 * /
        беззнаковый час; / *0 - 23 * /
        беззнаковая минута; / *0 - 59 * /
        беззнаковая секунда; / *0 - 60 (с учетом дополнительных секунд) * /
} LodePNGTime;
#endif / * LODEPNG_COMPILE_ANCILLARY_CHUNKS * /

/ *Информация об изображении PNG, кроме пикселей, ширины и высоты.* /
typedef struct LodePNGInfo {
    / *блоки заголовка(IHDR), палитры(PLTE) и прозрачности(tRNS)* /
        unsigned Compression_method; / *метод сжатия исходного файла.Всегда 0. * /
        беззнаковый filter_method; / *метод фильтрации исходного файла * /
        беззнаковый interlace_method; / *метод чередования исходного файла : 0 = нет, 1 = Adam7 * /
        LodePNGColorMode color; / *тип цвета и биты, палитра и прозрачность файла PNG* /

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
        / *
        Предлагаемый фрагмент цвета фона(bKGD)

        Здесь используется тот же цветовой режим и битовая глубина, что и в PNG(за исключением отсутствия альфа - канала),
        со значениями, усеченными до разрядности целого числа без знака.

        Для изображений PNG с оттенками серого и палитры значение сохраняется в background_r.Ценности
        в background_g и background_b тогда не используются.

        Поэтому при декодировании вы можете получить их в другом цветовом режиме, чем тот, который вы запрашивали.
        для необработанных пикселей.

        При кодировании с auto_convert необходимо использовать цветовую модель, определенную в info_png.color для
        эти значения.Кодировщик обычно игнорирует info_png.color, когда auto_convert включен, но будет
        используйте его для интерпретации этих значений(и преобразования их копий в выбранную цветовую модель).

        При кодировании избегайте установки дорогостоящего цвета, такого как значение, отличное от серого.
        когда изображение станет серым, иначе сжатие будет хуже, так как оно будет вынуждено
        напишите PNG с более дорогим цветовым режимом(когда auto_convert включен).

        Декодер не использует этот цвет фона для редактирования цвета пикселей.Это
        полностью необязательная функция метаданных.
        * /
        беззнаковый background_defined; / *указан предлагаемый цвет фона ? */
        беззнаковый background_r; / *красный / серый / компонент палитры предлагаемого цвета фона * /
        беззнаковый background_g; / *зеленый компонент предлагаемого цвета фона * /
        беззнаковый background_b; / *синий компонент предлагаемого цвета фона * /

        / *
        Немеждународные фрагменты текста(tEXt и zTXt)

        Каждый массив char** содержит количество строк.Фактические сообщения находятся в
        text_strings, а text_keys - это ключевые слова, дающие краткое описание того, что
        фактический текст представляет, например, название, автора, описание или что - то еще.

        Все строковые поля ниже, включая строки, ключи, имена и языковые теги, завершаются нулем.
        Спецификация PNG использует нулевые символы для ключей, имен и тегов и запрещает нулевые символы.
        символы должны появляться в основном тексте, поэтому мы можем использовать здесь везде нулевое завершение.

        Ключевое слово состоит минимум из 1 символа и максимум 79 символов(плюс
            дополнительный нулевой ограничитель).Не рекомендуется использовать одинарную длину строки
        длиннее 79 знаков для текстов.

        Не выделяйте эти текстовые буферы самостоятельно.Используйте функции инициализации / очистки
        правильно и используйте lodepng_add_text и lodepng_clear_text.

        Ключевые слова и строки стандартных текстовых блоков кодируются с использованием Latin - 1.
        * /
        size_t text_num; / *количество текстов в этих char** буферах(в itext текстов может быть больше) * /
        char** text_keys; / *ключевое слово фрагмента текста(например, «Комментарий») * /
        char** text_strings; / *собственно текст * /

        / *
        Международные фрагменты текста(iTXt)
        Подобно немеждународным фрагментам текста, но с дополнительными строками
        Используются «langtags» и «transkeys», а также следующие кодировки текста :
ключи: Latin - 1, langtags : ASCII, трансключи и строки : UTF - 8.
ключи должны состоять из 1 - 79 символов(плюс дополнительный нулевой терминатор), остальные
струны любой длины.
* /
size_t itext_num; / *количество международных текстов в этом PNG * /
char** itext_keys; / *английское ключевое слово фрагмента текста(например, "Комментарий") * /
char** itext_langtags; / *языковой тег для языка этого текста, строка ISO / IEC 646, например языковой тег ISO 639 * /
char** itext_transkeys; / *ключевое слово переведено на международный язык - строка UTF - 8 * /
char** itext_strings; / *актуальный международный текст - строка UTF - 8 * /

/ *отрезок времени(tIME) * /
беззнаковый time_defined; / *установлен в 1, чтобы кодировщик сгенерировал отрезок времени* /
LodePNGTime time;

/ *физический фрагмент(pHYs) * /
беззнаковый Phys_defined; / *если 0, фрагмент pHYs отсутствует и значения ниже не определены, если 1, иначе есть один* /
беззнаковый Phys_x; / *пикселей на единицу по оси x * /
беззнаковый Phys_y; / *пикселей на единицу по оси y * /
беззнаковый Phys_unit; / *может быть 0 (неизвестная единица измерения) или 1 (метр) * /

/ *
Фрагменты, связанные с цветовым профилем : gAMA, cHRM, sRGB, iCPP

LodePNG не применяет преобразование цвета к пикселям в кодировщике или декодере и не интерпретирует эти цвета.
значения профиля.Он просто передает информацию.Если вы хотите использовать цветовые профили и конвертировать цвета, пожалуйста,
используйте эти значения с библиотекой управления цветом.

Дополнительные сведения о значении этих значений см.В спецификациях PNG, ICC и sRGB.
* /

/ *фрагмент gAMA : необязательный, заменяется sRGB или iCCP, если они есть.* /
беззнаковый gama_defined; / *Наличие блока gAMA(0 = нет, 1 = присутствует). * /
беззнаковая gama_gamma; / *Показатель гаммы, умноженный на 100000 * /

/ *фрагмент cHRM : необязательный, заменяется sRGB или iCCP, если они присутствуют.* /
беззнаковый chrm_defined; / *Наличие блока cHRM(0 = нет, 1 = присутствует). * /
беззнаковый chrm_white_x; / *Точка белого x умноженная на 100000 * /
беззнаковый chrm_white_y; / *Точка белого y умноженная на 100000 * /
беззнаковый chrm_red_x; / *Красный x раз 100000 * /
беззнаковый chrm_red_y; / *Красный y умножить на 100000 * /
беззнаковый chrm_green_x; / *Зеленый x умножить на 100000 * /
беззнаковый chrm_green_y; / *Зеленый y умножить на 100000 * /
беззнаковый chrm_blue_x; / *Синий x умноженный на 100000 * /
беззнаковый chrm_blue_y; / *Синий y умножить на 100000 * /

/ *
Блок sRGB : необязательно.Может не отображаться одновременно с iCCP.
Если также присутствует gAMA, gAMA должно содержать значение 45455.
Если cHRM также присутствует, cHRM должен содержать соответственно 31270, 32900, 64000, 33000, 30000, 60000, 15000, 6000.
* /
беззнаковый srgb_defined; / *Наличие блока sRGB(0 = нет, 1 = присутствует). * /
беззнаковый srgb_intent; / *Способ визуализации : 0 = перцепционный, 1 = отн.колориметрический, 2 = насыщенность, 3 = абс.колориметрический * /

/ *
Блок iCCP : необязательно.Может не отображаться одновременно с sRGB.

LodePNG не анализирует и не использует профиль ICC(за исключением поля заголовка цветового пространства для крайнего случая),
отдельная библиотека для обработки данных ICC(не входит в LodePNG) формат необходима для использования ее для цвета
управление и преобразования.

Для кодирования, если присутствует iCCP, рекомендуется также добавить gAMA и cHRM со значениями, соответствующими ICC.
профиль как можно точнее, если вы хотите сделать это, вы должны указать правильные значения для gAMA и cHRM и
включите их флаги '_defined', поскольку LodePNG не будет автоматически вычислять их из профиля ICC.

Для кодирования профиль ICC согласно спецификации PNG должен быть профилем «RGB» для не - серых
Цветовые типы PNG и профиль «СЕРЫЙ» для серых цветовых типов PNG.Если вы отключите auto_convert, вы должны убедиться, что
тип профиля ICC соответствует запрошенному типу цвета, иначе кодировщик выдаст ошибку.Если auto_convert -
включен(по умолчанию), а профиль ICC не подходит для данных пикселей, это приведет к тому, что кодировщик
ошибка, если пиксельные данные содержат не серые пиксели для СЕРЫХ профилей, или тихое менее оптимальное сжатие пикселя
data, если пиксели могут быть закодированы как оттенки серого, но профиль ICC - RGB.

Чтобы избежать этого, не устанавливайте профиль ICC в изображении, если для этого нет веской причины, и при этом
убедитесь, что вы вычислили его внимательно, чтобы избежать вышеуказанных проблем.
* /
беззнаковый iccp_defined; / *Наличие блока iCCP(0 = нет, 1 = присутствует). * /
char* iccp_name; / *Строка с завершающим нулем и именем профиля, 1 - 79 байт * /
/ *
Профиль ICC в байтах iccp_profile_size.
Не выделяйте этот буфер самостоятельно.Используйте функции инициализации / очистки
правильно и используйте lodepng_set_icc и lodepng_clear_icc.
* /
беззнаковый символ * iccp_profile;
беззнаковый iccp_profile_size; / *Размер iccp_profile в байтах * /

/ *Конец фрагментов, связанных с цветовым профилем* /


/ *
неизвестные фрагменты : фрагменты, неизвестные LodePNG, передаваемые байтом за байтом.

Есть 3 буфера, по одному на каждую позицию в PNG, где могут появляться неизвестные фрагменты.
Каждый буфер последовательно содержит все неизвестные фрагменты для этой позиции.
3 позиции :
    0 : между IHDR и PLTE, 1 : между PLTE и IDAT, 2 : между IDAT и IEND.

    Для кодирования не храните критические или известные фрагменты, которые включены с флагом "_defined".
    выше здесь, поскольку кодировщик будет слепо следовать этому и затем может кодировать недопустимый файл PNG
    (например, с двумя фрагментами IHDR или запрещенной комбинацией sRGB с iCCP).Но используйте
    это, если вы хотите сохранить вспомогательный фрагмент, который не поддерживается LodePNG(например, sPLT или hIST),
    или любой нестандартный фрагмент PNG.

    Не размещайте и не просматривайте эти данные самостоятельно.Используйте объявленные функции обхода фрагментов
    позже, например, lodepng_chunk_next и lodepng_chunk_append, для чтения / записи этой структуры.
    * /
    беззнаковый символ * unknown_chunks_data[3];
size_t unknown_chunks_size[3]; / *размер неизвестных фрагментов в байтах, предоставленных для защиты* /
#endif / * LODEPNG_COMPILE_ANCILLARY_CHUNKS * /
} LodePNGInfo;

/ *функции инициализации, очистки и копирования для использования с этой структурой* /
void lodepng_info_init(LodePNGInfo * информация);
void lodepng_info_cleanup(LodePNGInfo* информация);
/ *возвращаемое значение - код ошибки(0 означает отсутствие ошибки) * /
беззнаковый lodepng_info_copy(LodePNGInfo * dest, const LodePNGInfo * source);

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
беззнаковый lodepng_add_text(LodePNGInfo* info, const char* key, const char* str); / *отодвинуть оба текста одновременно * /
void lodepng_clear_text(LodePNGInfo * информация); / *используйте это, чтобы снова очистить тексты после того, как вы их заполнили* /

беззнаковый lodepng_add_itext(LodePNGInfo * info, const char* key, const char* langtag,
    const char* transkey, const char* str); / *отодвинуть сразу 4 текста 1 чанка * /
    void lodepng_clear_itext(LodePNGInfo * информация); / *используйте это, чтобы снова очистить itexts после того, как вы их заполнили* /

    / *заменяет, если существует* /
    беззнаковый lodepng_set_icc(LodePNGInfo * info, const char* name, const unsigned char* profile, unsigned profile_size);
void lodepng_clear_icc(LodePNGInfo* информация); / *используйте это, чтобы снова очистить тексты после того, как вы их заполнили* /
#endif / * LODEPNG_COMPILE_ANCILLARY_CHUNKS * /

/ *
Преобразует необработанный буфер из одного цветового типа в другой цветовой тип на основе
LodePNGColorMode - структуры для описания типа цвета ввода и вывода.
См.Справочное руководство в конце этого заголовочного файла, чтобы узнать, какие преобразования цветов поддерживаются.
возвращаемое значение = код ошибки LodePNG(0, если все прошло нормально, ошибка, если преобразование не поддерживается)
Выходной буфер должен иметь размер(w * h * bpp + 7) / 8, где bpp - количество бит на пиксель.
цветного типа вывода(lodepng_get_bpp).
Для изображений < 8 бит на пиксель не должно быть битов заполнения в конце строк развертки.
    Для 16 - битных цветов на канал используется формат с прямым порядком байтов, как в PNG.
    Возвращаемое значение - код ошибки LodePNG.
    * /
    беззнаковый lodepng_convert(unsigned char* out, const unsigned char* in,
        const LodePNGColorMode * mode_out, const LodePNGColorMode * mode_in,
        беззнаковый w, беззнаковый h);

#ifdef LODEPNG_COMPILE_DECODER
/ *
Настройки для декодера.Он содержит настройки для PNG и Zlib.
decoder, но не в настройках Info из структур Info.
* /
typedef struct LodePNGDecoderSettings {
    LodePNGDecompressSettings zlibsettings; / *здесь настройка игнорирования контрольных сумм Adler32 * /

        / *Проверьте LodePNGDecompressSettings на наличие более игнорируемых ошибок, таких как ignore_adler32* /
        беззнаковый ignore_crc; / *игнорировать контрольные суммы CRC * /
        беззнаковый ignore_critical; / *игнорировать неизвестные критические блоки * /
        беззнаковый ignore_end; / *игнорировать проблемы в конце файла, если это возможно(отсутствующий фрагмент IEND, слишком большой фрагмент, ...)* /
        / *TODO: вместо этого создать систему, включающую предупреждения с уровнями и строгим режимом.Другое потенциально извлекаемое
        ошибки : значение намерения рендеринга srgb, размер содержимого вспомогательных чанков, более 79 символов для некоторых
        строки, правила размещения / комбинирования для вспомогательных фрагментов, crc неизвестных фрагментов, разрешенные символы
        в строковых ключах и т.д.* /

        беззнаковый color_convert; / *нужно ли преобразовать PNG в нужный вам цветовой тип.По умолчанию : да * /

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
        беззнаковые read_text_chunks; / *если false, но Remember_unknown_chunks истинно, они сохраняются в неизвестных чанках* /

        / *сохранять все байты из неизвестных фрагментов в LodePNGInfo(по умолчанию отключено, полезно для редактора png) * /
        неподписанные Remember_unknown_chunks;

    / *максимальный размер фрагментов распакованного текста.Если текст фрагмента текста больше этого, возвращается ошибка,
        если только чтение фрагментов текста не отключено, или этот предел не установлен выше или не отключен.Установите 0, чтобы разрешить любой размер.
        По умолчанию это значение, которое предотвращает чрезмерно большие строки от перегрузки памяти.* /
        size_t max_text_size;

    / *максимальный размер сжатых фрагментов ICC.Если профиль ICC больше этого, будет возвращена ошибка.Установлен в
        0, чтобы разрешить любой размер.По умолчанию это значение, которое предотвращает профили ICC, которые были бы намного больше, чем любые
        законный профиль мог бы пожирать память.* /
        size_t max_icc_size;
#endif / * LODEPNG_COMPILE_ANCILLARY_CHUNKS * /
} LodePNGDecoderSettings;

void lodepng_decoder_settings_init(настройки LodePNGDecoderSettings*);
#endif / * LODEPNG_COMPILE_DECODER * /

#ifdef LODEPNG_COMPILE_ENCODER
/ *автоматически использовать цветовой тип с меньшим количеством бит на пиксель, если это возможно без потерь.По умолчанию : АВТО * /
typedef enum LodePNGFilterStrategy {
    / *каждый фильтр в нуле * /
    LFS_ZERO = 0,
    / *каждый фильтр на 1, 2, 3 или 4 (paeth), в отличие от LFS_ZERO, не лучший выбор, но для тестирования* /
    LFS_ONE = 1,
    LFS_TWO = 2,
    LFS_THREE = 3,
    LFS_FOUR = 4,
    / *Используйте фильтр, который дает минимальную сумму, как описано в официальной эвристике фильтра PNG.* /
    LFS_MINSUM,
    / *Используйте тип фильтра, который дает наименьшую энтропию Шеннона для этой строки сканирования.В зависимости от
    на изображении это лучше или хуже, чем minsum.* /
    LFS_ENTROPY,
    / *
    PNG фильтрует грубой силы путем сжатия каждого фильтра для каждой строки развертки.
    Экспериментально, очень медленно и редко дает лучшее сжатие, чем MINSUM.
    * /
    LFS_BRUTE_FORCE,
    / *использовать буфер предопределенных_фильтров : вы указываете тип фильтра для каждой строки сканирования * /
    LFS_PREDEFINED
} LodePNGFilterStrategy;

/ *Дает характеристики о целочисленных цветах RGBA изображения(количество, использование альфа - канала, битовая глубина, ...),
который помогает решить, какую цветовую модель использовать для кодирования.
Используется для внутреннего использования по умолчанию, если "auto_convert" включен.Общедоступно, потому что это полезно для пользовательских алгоритмов.* /
typedef struct LodePNGColorStats {
    беззнаковые цветные; / *без оттенков серого * /
        беззнаковый ключ; / *изображение не является непрозрачным и возможен цветной ключ вместо полной альфа * /
        беззнаковый короткий key_r; / *значения ключей, всегда 16 - битные, в 8 - битном случае байт дублируется, например 65535 означает 255 * /
        беззнаковый короткий key_g;
    беззнаковый короткий key_b;
    беззнаковый альфа; / *изображение непрозрачное, и требуется альфа - канал или альфа - палитра * /
        беззнаковые числа; / *количество цветов, до 257. Недопустимо, если биты == 16 или allow_palette отключены. * /
        палитра беззнаковых символов[1024]; / *Запоминает до первых 256 цветов RGBA в произвольном порядке, действует только тогда, когда numcolors действительны* /
        беззнаковые биты; / *бит на канал(не для палитры). 1, 2 или 4 только для оттенков серого. 16, если требуется 16 бит на канал. * /
        size_t numpixels;

    / *пользовательские настройки для расчета / использования статистики * /
        беззнаковый allow_palette; / *по умолчанию 1. если 0, запретить выбор цвета палитры в auto_choose_color и не считать numcolors* /
        беззнаковый allow_greyscale; / *по умолчанию 1. если 0, выбрать RGB или RGBA, даже если изображение имеет только серые цвета* /
} LodePNGColorStats;

void lodepng_color_stats_init(LodePNGColorStats* stats);

/ *Получить LodePNGColorStats изображения.Статистика должна быть уже введена.
Возвращает код ошибки(например, сбой выделения) или 0, если все в порядке.* /
беззнаковый lodepng_compute_color_stats(LodePNGColorStats * stats,
    const беззнаковый символ * изображение, беззнаковый ш, беззнаковый ч,
    const LodePNGColorMode * mode_in);

/ *Настройки кодировщика. * /
typedef struct LodePNGEncoderSettings {
    LodePNGCompressSettings zlibsettings; / *настройки для кодировщика zlib, такие как размер окна, ... * /

        беззнаковый auto_convert; / *автоматически выбираем тип цвета вывода PNG.По умолчанию : true * /

        / *Если true, следует официальной эвристике PNG : если PNG использует палитру или ниже
        8 - битная глубина, установите все фильтры на ноль.В противном случае используйте filter_strategy.Обратите внимание, что
        полностью следовать официальной эвристике PNG, filter_palette_zero должно быть истинным и
        filter_strategy должно быть LFS_MINSUM* /
        беззнаковый filter_palette_zero;
    / *Какую стратегию фильтрации использовать, если нули не используются из - за filter_palette_zero.
        Установите filter_palette_zero на 0, чтобы всегда использовать выбранную вами стратегию.По умолчанию : LFS_MINSUM * /
        LodePNGFilterStrategy filter_strategy;
    / *используется, если filter_strategy LFS_PREDEFINED.В этом случае это должно указывать на буфер с
        той же длины, что и количество строк развертки в изображении, и каждое значение должно быть <= 5. Вы
        необходимо очистить этот буфер, LodePNG никогда его не освободит.Не забывайте, что filter_palette_zero
        должен быть установлен в 0, чтобы гарантировать, что это также используется для палитры или изображений с низкой битовой глубиной.* /
        const беззнаковый символ * предопределенные_фильтры;

    / *принудительное создание блока PLTE, если тип цвета 2 или 6 (= предлагаемая палитра).
        Если тип цвета 3, PLTE создается _всегда_.* /
        беззнаковый force_palette;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    / *добавляем идентификатор и версию LodePNG в виде текстового фрагмента для отладки * /
        беззнаковый add_id;
    / *кодировать фрагменты текста как фрагменты zTXt вместо фрагментов текста и использовать сжатие в фрагментах iTXt * /
        беззнаковое сжатие текста;
#endif / * LODEPNG_COMPILE_ANCILLARY_CHUNKS * /
} LodePNGEncoderSettings;

void lodepng_encoder_settings_init(настройки LodePNGEncoderSettings*);
#endif / * LODEPNG_COMPILE_ENCODER * /


# если определено(LODEPNG_COMPILE_DECODER) || определено(LODEPNG_COMPILE_ENCODER)
/ *Настройки, состояние и информация для расширенного кодирования и декодирования.* /
typedef struct LodePNGState {
#ifdef LODEPNG_COMPILE_DECODER
    LodePNGDecoderSettings decoder; / *настройки декодирования * /
#endif / * LODEPNG_COMPILE_DECODER * /
#ifdef LODEPNG_COMPILE_ENCODER
        Кодировщик LodePNGEncoderSettings; / *настройки кодировки * /
#endif / * LODEPNG_COMPILE_ENCODER * /
        LodePNGColorMode info_raw; / *задает формат, в котором вы хотите получить буфер необработанных пикселей* /
        LodePNGInfo info_png; / *информация о PNG - изображении, полученном после декодирования* /
        беззнаковая ошибка;
} LodePNGState;

/ *функции инициализации, очистки и копирования для использования с этой структурой* /
void lodepng_state_init(состояние LodePNGState*);
void lodepng_state_cleanup(состояние LodePNGState*);
void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source);
#endif / * определено (LODEPNG_COMPILE_DECODER) || определено (LODEPNG_COMPILE_ENCODER) * /

#ifdef LODEPNG_COMPILE_DECODER
/ *
То же, что и lodepng_decode_memory, но использует LodePNGState, чтобы разрешить пользовательские настройки и
получить больше информации об изображении PNG и цветовом режиме.
* /
беззнаковый lodepng_decode(unsigned char** out, unsigned* w, unsigned* h,
    Состояние LodePNGState*,
    const unsigned char* in, size_t insize);

/ *
Прочтите заголовок PNG, но не сами данные.Это возвращает только информацию
который находится в блоке IHDR PNG, такой как ширина, высота и тип цвета.В
информация помещается в поле info_png в LodePNGState.
* /
беззнаковый lodepng_inspect(беззнаковый * w, беззнаковый * h,
    Состояние LodePNGState*,
    const unsigned char* in, size_t insize);
#endif / * LODEPNG_COMPILE_DECODER * /

/ *
Считывает один фрагмент метаданных(кроме IHDR) файла PNG и выводит то, что он
читайте в гос.В случае сбоя возвращает код ошибки.
Сначала используйте lodepng_inspect с новым состоянием, затем, например, lodepng_chunk_find_const
чтобы найти желаемый тип блока, а если не null, используйте lodepng_inspect_chunk(с
    chunk_pointer - начальный_файл как поз).
    Поддерживает большинство фрагментов метаданных из стандарта PNG(gAMA, bKGD, tEXt, ...).
    Игнорирует неподдерживаемые, неизвестные, неметаданные или фрагменты IHDR(без ошибок).
    Требования: &in[pos] должен указывать на начало чанка, использовать обычный
    lodepng_inspect первым, поскольку формат большинства других фрагментов зависит от IHDR, и если
    есть блок PLTE, который необходимо проверить перед tRNS или bKGD.
    * /
    беззнаковый lodepng_inspect_chunk(LodePNGState * состояние, size_t pos,
        const unsigned char* in, size_t insize);

#ifdef LODEPNG_COMPILE_ENCODER
/ *Эта функция выделяет выходной буфер с помощью стандартного malloc и сохраняет размер в * большом размере. * /
беззнаковый lodepng_encode(unsigned char** out, size_t * overize,
    const беззнаковый символ * изображение, беззнаковый ш, беззнаковый ч,
    LodePNGState * состояние);
#endif / * LODEPNG_COMPILE_ENCODER * /

/ *
Функции lodepng_chunk обычно не нужны, кроме
неизвестные фрагменты, хранящиеся в структуре LodePNGInfo, или добавить в нее новые.
Он также позволяет самостоятельно перемещаться по фрагментам закодированного файла PNG.

Указатель блока всегда указывает на начало самого блока, то есть
первый байт из 4 байтов длины.

В формате файла PNG чанки имеют следующий формат :
-4 байта : длина данных чанка в байтах(сам чанк на 12 байт длиннее)
Тип блока - 4 байта(только ASCII az, AZ, см.Ниже)
- длина байтов данных(может быть 0 байтов, если длина была 0)
- 4 байта CRC, вычисляемого для имени блока + данные

Первый фрагмент начинается с 8 - го байта файла PNG, весь остальной файл
существует из объединенных фрагментов в указанном выше формате.

Стандартные правила именования ASCII фрагментов PNG :
-Первый байт : верхний регистр = критический, нижний регистр = вспомогательный
- Второй байт : верхний регистр = общедоступный, нижний регистр = частный
- Третий байт : должен быть в верхнем регистре
- Четвертый байт : верхний регистр = копировать небезопасно, нижний регистр = безопасно копировать
* /

/ *
Получает длину данных блока.Общая длина блока на 12 байтов больше.
Для чтения должно быть не менее 4 байтов.Если значение результата слишком велико,
это могут быть поврежденные данные.
* /
беззнаковый lodepng_chunk_length(const unsigned char* chunk);

/ *помещает 4 - байтовый тип в строку с завершающим нулем * /
void lodepng_chunk_type(тип символа[5], const unsigned char* chunk);

/ *проверяем, соответствует ли тип заданному типу* /
беззнаковый символ lodepng_chunk_type_equals(const unsigned char* chunk, const char* type);

/ *0: это один из критических типов блоков, 1 : это вспомогательный блок(см.Стандарт PNG) * /
беззнаковый символ lodepng_chunk_ancillary(const unsigned char* chunk);

/ *0: общедоступный, 1 : частный(см.Стандарт PNG) * /
беззнаковый символ lodepng_chunk_private(const unsigned char* chunk);

/ *0: чанк небезопасно копировать, 1 : чанк можно копировать(см.Стандарт PNG) * /
беззнаковый символ lodepng_chunk_safetocopy(const unsigned char* chunk);

/ *получаем указатель на данные чанка, где ввод указывает на заголовок чанка* /
беззнаковый символ * lodepng_chunk_data(беззнаковый символ * чанк);
const unsigned char* lodepng_chunk_data_const(const unsigned char* chunk);

/ *возвращает 0, если crc правильный, 1, если он неправильный(0 для ОК, как обычно!)* /
беззнаковый lodepng_chunk_check_crc(const unsigned char* chunk);

/ *генерирует правильный CRC из данных и помещает его в последние 4 байта чанка * /
void lodepng_chunk_generate_crc(unsigned char* chunk);

/ *
Переход к следующим фрагментам, позволяет перебирать все фрагменты файла PNG.
Ввод должен быть в начале блока(результат предыдущего вызова lodepng_chunk_next,
    или 8 - й байт файла PNG, который всегда имеет первый фрагмент), или, альтернативно, может
    указывает на первый байт файла PNG(который является не фрагментом, а волшебным заголовком,
        функция затем пропустит его и вернет первый реальный фрагмент).
    Будет выводить указатель на начало следующего фрагмента или на конец файла или за его пределами, если есть
    после этого больше не будет фрагмента или, возможно, если фрагмент поврежден.
    Начните этот процесс с 8 - го байта файла PNG.
    В неповрежденном файле PNG последний фрагмент должен иметь имя «IEND».
    * /
    беззнаковый символ * lodepng_chunk_next(беззнаковый символ * чанк, беззнаковый символ * конец);
const unsigned char* lodepng_chunk_next_const(const unsigned char* chunk, const unsigned char* end);

/ *Находит первый кусок с заданным типом в диапазоне[chunk, end) или возвращает NULL, если не найден.* /
беззнаковый символ * lodepng_chunk_find(беззнаковый символ * кусок, беззнаковый символ * конец, тип константного символа[5]);
const unsigned char* lodepng_chunk_find_const(const unsigned char* chunk, const unsigned char* end, const char type[5]);

/ *
Добавляет фрагмент данных на выходе.У данного блока уже должен быть заголовок блока.
Переменная out и размер обновляются, чтобы отразить новый перераспределенный буфер.
Возвращает код ошибки(0, если все прошло нормально)
* /
беззнаковый lodepng_chunk_append(unsigned char** out, size_t * outize, const unsigned char* chunk);

/ *
Добавляет новый чанк к выходу.Добавляемый кусок задается его длиной, типом
и данные отдельно.Тип представляет собой строку из 4 букв.
Переменная out и размер обновляются, чтобы отразить новый перераспределенный буфер.
Код ошибки возврата(0, если все прошло нормально)
* /
беззнаковый lodepng_chunk_create(unsigned char** out, size_t * outize, беззнаковая длина,
    const char* type, const unsigned char* data);


/ *Вычислить CRC32 буфера * /
беззнаковый lodepng_crc32(const unsigned char* buf, size_t len);
#endif / * LODEPNG_COMPILE_PNG * /


#ifdef LODEPNG_COMPILE_ZLIB
/ *
Эта часть zlib может использоваться независимо для сжатия и распаковки zlib
буфер.Однако его нельзя использовать для создания файлов gzip, и он поддерживает только
часть zlib, необходимая для PNG, она не поддерживает словари.
* /

#ifdef LODEPNG_COMPILE_DECODER
/ *Наполняем буфер.Надувание - это этап декомпрессии при сдутии.После использования выходной буфер должен быть освобожден. * /
беззнаковый lodepng_inflate(unsigned char** out, size_t * outize,
    const unsigned char* in, size_t insize,
    const LodePNGDecompressSettings * settings);

/ *
Распаковывает данные Zlib.Перераспределяет выходной буфер и добавляет данные.В
данные должны соответствовать спецификации zlib.
Либо * out должен быть NULL и * outize должен быть 0, либо* out должен быть допустимым
buffer и* увеличить его размер в байтах.out должен быть освобожден пользователем после использования.
* /
беззнаковый lodepng_zlib_decompress(unsigned char** out, size_t * outize,
    const unsigned char* in, size_t insize,
    const LodePNGDecompressSettings * settings);
#endif / * LODEPNG_COMPILE_DECODER * /

#ifdef LODEPNG_COMPILE_ENCODER
/ *
Сжимает данные с помощью Zlib.Перераспределяет выходной буфер и добавляет данные.
Zlib добавляет небольшой заголовок и трейлер вокруг данных выкачивания.
Данные выводятся в формате спецификации zlib.
Либо * out должен быть NULL и * outize должен быть 0, либо* out должен быть допустимым
buffer и* увеличить его размер в байтах.out должен быть освобожден пользователем после использования.
* /
беззнаковый lodepng_zlib_compress(unsigned char** out, size_t * outize,
    const unsigned char* in, size_t insize,
    const LodePNGCompressSettings * settings);

/ *
Найдите ограниченный по длине код Хаффмана для заданных частот.Эта функция находится в
открытый интерфейс только для тестов, он используется внутри lodepng_deflate.
* /
беззнаковый lodepng_huffman_code_lengths(беззнаковые * длины, const беззнаковые * частоты,
    size_t numcodes, беззнаковый maxbitlen);

/ *Сжимаем буфер с помощью deflate.См.RFC 1951. Выходной буфер должен быть освобожден после использования. * /
беззнаковый lodepng_deflate(unsigned char** out, size_t * outize,
    const unsigned char* in, size_t insize,
    const LodePNGCompressSettings * settings);

#endif / * LODEPNG_COMPILE_ENCODER * /
#endif / * LODEPNG_COMPILE_ZLIB * /

#ifdef LODEPNG_COMPILE_DISK
/ *
Загрузить файл с диска в буфер.Функция выделяет выходной буфер и
после использования его следует освободить.
out: выходной параметр, содержит указатель на загруженный буфер.
outize : выходной параметр, размер выделенного буфера
filename : путь к файлу для загрузки
возвращаемое значение : код ошибки(0 означает ОК)

ПРИМЕЧАНИЕ.Имена файлов с расширенными символами не поддерживаются, вы можете использовать внешний метод.
для обработки таких файлов и декодирования в памяти.
* /
беззнаковый lodepng_load_file(unsigned char** out, size_t * outize, const char* filename);

/ *
Сохраните файл из буфера на диск.Предупреждение, если он существует, эта функция перезаписывает
файл без предупреждения!
буфер: буфер для записи
buffersize : размер буфера для записи
filename : путь к файлу для сохранения
возвращаемое значение : код ошибки(0 означает ОК)

ПРИМЕЧАНИЕ.Имена файлов с расширенными символами не поддерживаются, вы можете использовать внешний метод.
для обработки таких файлов и кодирования в памяти
* /
беззнаковый lodepng_save_file(const unsigned char* buffer, size_t buffersize, const char* filename);
#endif / * LODEPNG_COMPILE_DISK * /

#ifdef LODEPNG_COMPILE_CPP
/ *Оболочка LodePNG C ++ использует std::vectors вместо выделенных вручную буферов памяти. * /
namespace lodepng {
#ifdef LODEPNG_COMPILE_PNG
    class State : public LodePNGState {
    общественность:
        Состояние();
        Состояние(постоянное состояние и другое);
        ~Состояние();
        Состояние& оператор = (постоянное состояние и другое);
    };

#ifdef LODEPNG_COMPILE_DECODER
    / *То же, что и другие lodepng::decode, но с использованием состояния для дополнительных настроек и информации.* /
        декодирование без знака(std::vector <unsigned char> &out, unsigned& w, unsigned& h,
            Состояние и состояние,
            const unsigned char* in, size_t insize);
    декодирование без знака(std::vector <unsigned char>& out, unsigned& w, unsigned& h,
        Состояние и состояние,
        const std::vector <unsigned char>& in);
#endif / * LODEPNG_COMPILE_DECODER * /

#ifdef LODEPNG_COMPILE_ENCODER
    / *То же, что и другие lodepng::encode, но с использованием состояния для дополнительных настроек и информации.* /
        кодирование без знака(std::vector <unsigned char> &out,
            const беззнаковый символ * in, беззнаковый w, беззнаковый h,
            Состояние и состояние);
    кодирование без знака(std::vector <unsigned char>& out,
        const std::vector <unsigned char>& in, беззнаковый w, беззнаковый h,
        Состояние и состояние);
#endif / * LODEPNG_COMPILE_ENCODER * /

#ifdef LODEPNG_COMPILE_DISK
    / *
        Загрузите файл с диска в std::vector.
        возвращаемое значение : код ошибки(0 означает ОК)

        ПРИМЕЧАНИЕ.Имена файлов с расширенными символами не поддерживаются, вы можете использовать внешний метод.
        для обработки таких файлов и декодирования в памяти
        * /
        беззнаковый load_file(std::vector <unsigned char> &buffer, const std::string & filename);

    / *
        Сохраните двоичные данные в std::vector в файл на диске.Файл перезаписан
        без предупреждения.

        ПРИМЕЧАНИЕ.Имена файлов с расширенными символами не поддерживаются, вы можете использовать внешний метод.
        для обработки таких файлов и кодирования в памяти
        * /
        беззнаковый save_file(const std::vector <unsigned char> &buffer, const std::string & filename);
#endif / * LODEPNG_COMPILE_DISK * /
#endif / * LODEPNG_COMPILE_PNG * /

#ifdef LODEPNG_COMPILE_ZLIB
#ifdef LODEPNG_COMPILE_DECODER
    / *Zlib - распаковка буфера беззнаковых символов * /
        беззнаковая распаковка(std::vector <unsigned char> &out, const unsigned char* in, size_t insize,
            const LodePNGDecompressSettings & settings = lodepng_default_decompress_settings);

    / *Zlib - распаковка std::vector * /
        беззнаковая распаковка(std::vector <unsigned char> &out, const std::vector <unsigned char> &in,
            const LodePNGDecompressSettings & settings = lodepng_default_decompress_settings);
#endif / * LODEPNG_COMPILE_DECODER * /

#ifdef LODEPNG_COMPILE_ENCODER
    / *Zlib - сжатие буфера беззнаковых символов * /
        беззнаковое сжатие(std::vector <unsigned char> &out, const unsigned char* in, size_t insize,
            const LodePNGCompressSettings & settings = lodepng_default_compress_settings);

    / *Zlib - сжатие std::vector * /
        сжатие без знака(std::vector <unsigned char> &out, const std::vector <unsigned char> &in,
            const LodePNGCompressSettings & settings = lodepng_default_compress_settings);
#endif / * LODEPNG_COMPILE_ENCODER * /
#endif / * LODEPNG_COMPILE_ZLIB * /
} / *пространство имен lodepng * /
#endif / * LODEPNG_COMPILE_CPP * /

/ *
ДЕЛАТЬ:
[.] проверить, нет ли утечек памяти или уязвимостей безопасности - сделано много, но нужно часто проверять
[.] проверить совместимость с различными компиляторами - выполнено, но необходимо переделывать для каждой новой версии
[X] преобразование цвета в 16 - битные типы на канал
[X] поддерживают типы фрагментов цветового профиля(но никогда не позволяйте им касаться значений RGB по умолчанию)
[] поддерживает все общедоступные типы фрагментов PNG(почти готово, кроме sBIT, sPLT и hIST)
[] убедитесь, что кодировщик не генерирует фрагменты размером > (2 ^ 31) - 1
[] частичное декодирование(потоковая обработка)
[X] разрешите функции isFullyOpaque проверять цветовые ключи и прозрачные палитры.
[X] лучшее название для переменных «коды», «кодыD», «коды длины кода», «clcl» и «lldl»
[] позволяют обрабатывать некоторые ошибки, например предупреждения, когда изображение можно восстановить(например, 69, 57, 58)
[] сделать предупреждения, например: палитра oob, сбой контрольной суммы, данные после идентификатора, неправильный / неизвестный фрагмент крита, отсутствие нулевого терминатора в тексте, ...
[] сообщения об ошибках с номерами строк(и версией)
[] ошибки в состоянии вместо кода возврата ?
[] новые ошибки / предупреждения, такие как подозрительно большой распакованный ztxt или блок iccp
[] позволить оболочке C ++ перехватывать исключения из стандартной библиотеки и возвращать коды ошибок LodePNG
[] позволяют пользователю предоставлять пользовательские функции преобразования цвета, например, для предварительно умноженного альфа, битов заполнения или нет, ...
[] разрешить пользователю передавать данные(void*) настраиваемому распределителю
[X] предоставляет альтернативы для функций библиотеки C, отсутствующих на некоторых платформах(memcpy, ...)
* /

#endif / * Защита включения LODEPNG_H * /

/ *
Документация LodePNG
-------------------- -

0. оглавление
--------------------

1. о
1.1.поддерживаемые функции
1.2.функции не поддерживаются
2. Версия C и C++
3. безопасность
4. расшифровка
5. кодирование
6. преобразование цвета
6.1.Типы цветов PNG
6.2.преобразование цвета
6.3.биты заполнения
6.4.Замечание о 16 битах на канал и порядке байтов
7. значения ошибок
8. куски и редактирование PNG
9. поддержка компилятора
10. примеры
10.1.пример декодера C++
10.2.пример декодера C
11. справочник по настройкам состояния
12. изменения
13. контактная информация


1. о
--------

PNG - это формат файла для хранения растровых изображений без потерь с хорошим сжатием,
поддержка разных цветотипов и альфа - канала.

LodePNG - это кодек PNG согласно Portable Network Graphics(PNG)
Спецификация(второе издание) - Рекомендация W3C от 10 ноября 2003 г.

Используемые спецификации :

*) Спецификация переносимой сетевой графики(PNG) (второе издание) :
    http ://www.w3.org/TR/2003/REC-PNG-20031110
    *) RFC 1950 ZLIB Compressed Data Format version 3.3:
http://www.gzip.org/zlib/rfc-zlib.html
*) RFC 1951 DEFLATE Спецификация формата сжатых данных, версия 1.3:
http://www.gzip.org/zlib/rfc-deflate.html

Самую последнюю версию LodePNG в настоящее время можно найти по адресу
http ://lodev.org/lodepng/

LodePNG работает как на C(ISO C90), так и на C++, с оболочкой C++, которая добавляет
дополнительная функциональность.

LodePNG существует из двух файлов :
-lodepng.h : файл заголовка для C и C++
- lodepng.c(pp) : дать ему имя lodepng.c или lodepng.cpp(или.cc) в зависимости от вашего использования

Если вы хотите начать использовать LodePNG прямо сейчас, не читая этот документ, получите
примеры с веб - сайта LodePNG, чтобы узнать, как использовать его в коде, или проверьте
меньшие примеры в главе 13 здесь.

LodePNG прост, но поддерживает только основные требования.Достигать
простоты, были выбраны следующие варианты дизайна : Нет зависимостей
на любой внешней библиотеке.Есть функции для декодирования и кодирования PNG с помощью
один вызов функции, и расширенные версии этих функций, принимающие
Структура LodePNGState, позволяющая указать или получить дополнительную информацию.По умолчанию
цвета необработанного изображения всегда RGB или RGBA, независимо от типа цвета
файл PNG использует.Для чтения и записи файлов есть простые функции :
конвертировать файлы в / из буферов в памяти.

Все это делает LodePNG подходящим для загрузки текстур в играх, демоверсиях и небольших
программ, ... Менее подходит для полноценных графических редакторов, загружающих PNG
по сети(требуется, чтобы все данные изображения были доступны, прежде чем можно будет декодировать
    begin), жизненно важные системы, ...

    1.1.поддерживаемые функции
    ---------------------- -

    Декодер поддерживает следующие функции :

*) декодирование PNG с любым типом цвета, битовой глубиной и режимом чересстрочной развертки в 24 - или 32 - битное цветное необработанное изображение,
или того же цветотипа, что и PNG
*) кодирование PNG, от любого необработанного изображения до 24 - или 32 - битного цвета или того же цветового типа, что и необработанное изображение
*) Adam7 чересстрочная развертка и деинтерлейсинг для любого цветотипа
*) загрузка изображения с жесткого диска или его декодирование из буфера из других источников, кроме жесткого диска
*) поддержка альфа - каналов, включая цветовую модель RGBA, полупрозрачные палитры и цветовую манипуляцию
*) zlib декомпрессия(надуть)
*) сжатие zlib(deflate)
*) Контрольные суммы CRC32 и ADLER32
*) преобразование колориметрического цветового профиля : в настоящее время экспериментально доступно только в lodepng_util.cpp,
плюс в качестве альтернативы возможность передавать информацию профиля цветности / гаммы / ICC в другую систему управления цветом.
*) обработка неизвестных фрагментов, позволяющая создать редактор PNG, в котором хранятся пользовательские и неизвестные фрагменты.
*) следующие блоки поддерживаются как кодировщиком, так и декодером :
IHDR: информация заголовка
PLTE : цветовая палитра
IDAT : пиксельные данные
IEND : последний кусок
tRNS : прозрачность для изображений с палитрой
ТЕКСТ : текстовая информация
zTXt : сжатая текстовая информация
iTXt : международная текстовая информация
bKGD : предлагаемый цвет фона
pHYs : физические размеры
tIME : время модификации
cHRM : цветности RGB
gAMA : гамма - коррекция RGB
iCCP : цветовой профиль ICC
sRGB : цель рендеринга

1.2.функции не поддерживаются
-------------------------- -

Следующие функции _не_ поддерживаются :

*) некоторые функции, необходимые для создания совместимого PNG - редактора, могут по - прежнему отсутствовать.
*) частичная загрузка / потоковая обработка.Все данные должны быть доступны и обрабатываются за один вызов.
*) Следующие публичные чанки(пока) не поддерживаются, но рассматриваются LodePNG как неизвестные чанки :
sBIT
СПИСОК
sPLT


2. Версия C и C++
--------------------

Версия C использует буферы, выделенные с помощью alloc, что вам нужно для free()
сам.Вам нужно использовать функции инициализации и очистки для каждой структуры всякий раз, когда
используя структуру из версии C, чтобы избежать эксплойтов и утечек памяти.

Версия C ++ имеет дополнительные функции с std::vectors в интерфейсе и
lodepng::State - класс LodePNGState с конструктором и деструктором.

Эти файлы работают без изменений для компиляторов C и C++, потому что все
дополнительный код C ++ находится в блоках "#ifdef __cplusplus", которые делают C - компиляторы
игнорируйте это, и код C будет компилироваться как со строгими стандартами ISO C90, так и с C++.

Чтобы использовать версию C++, вам необходимо переименовать исходный файл в lodepng.cpp
(вместо lodepng.c) и скомпилируйте его с помощью компилятора C++.

Чтобы использовать версию C, вам необходимо переименовать исходный файл в lodepng.c(вместо этого
    of lodepng.cpp) и скомпилировать его с помощью компилятора C.


    3. Безопасность
    ---------- -

    Даже при тщательном проектировании всегда возможно, что LodePNG содержит возможные
    подвиги.Если вы обнаружите одну из них, сообщите мне, и она будет исправлена.

    При использовании LodePNG следует проявлять осторожность и с версией LodePNG C.
    как структуры C - стиля при работе с C++.Используются следующие условные обозначения
    для всех структур в стиле C :

-если структура имеет соответствующую функцию инициализации, всегда вызывайте функцию инициализации при создании новой
- если структура имеет соответствующую функцию очистки, вызвать ее до того, как структура исчезнет, ​​чтобы избежать утечки памяти
- если структура имеет соответствующую функцию копирования, используйте функцию копирования вместо "=".
Пункт назначения также должен быть уже указан.


4. Расшифровка
---------- -

Декодирование преобразует сжатое изображение PNG в буфер необработанных пикселей.

Большая часть документации по использованию декодера находится в его объявлениях в заголовке.
выше.Для C простое декодирование может быть выполнено с помощью таких функций, как
lodepng_decode32, а более сложное декодирование можно выполнить с помощью struct
LodePNGState и lodepng_decode.Для C ++ все декодирование можно выполнить с помощью
различные функции lodepng::decode и lodepng::State могут использоваться для расширенных
Особенности.

При использовании LodePNGState для декодирования используются следующие поля :
*) LodePNGInfo info_png : здесь хранится дополнительная информация о PNG(вход)
*) LodePNGColorMode info_raw : здесь вы можете указать, какой цветовой режим необработанного изображения(вывода) вы хотите получить
*) Декодер LodePNGDecoderSettings : вы можете указать несколько дополнительных настроек для использования декодером

LodePNGInfo info_png
--------------------

После декодирования он содержит дополнительную информацию об изображении PNG, за исключением фактического
пикселей, ширины и высоты, потому что они уже получены непосредственно от декодера
функции.

Он содержит, например, исходный цветовой тип изображения PNG, текстовые комментарии,
предлагаемый цвет фона и т.д.Более подробную информацию о структуре LodePNGInfo можно найти
в своей декларационной документации.

LodePNGColorMode info_raw
------------------------ -

При декодировании здесь вы можете указать, какой цветовой тип вы хотите
полученное необработанное изображение должно быть.Если это отличается от цветотипа
PNG, тогда декодер автоматически конвертирует результат.Это преобразование
всегда работает, за исключением случаев, когда вы хотите преобразовать цветной PNG в оттенки серого или в
палитра с недостающими цветами.

По умолчанию для результата используется 32 - битный цвет.

LodePNGDecoderSettings декодер
------------------------------

Настройки могут использоваться для игнорирования ошибок, созданных недопустимым CRC и Adler32.
chunks, а также для отключения декодирования текстовых фрагментов.

Также есть параметр color_convert, по умолчанию true.Если false, конверсии нет.
готово, итоговые данные будут такими же, как и в PNG(после распаковки)
и вам придется самостоятельно разгадывать цвета пикселей, используя
информация о типе цвета в LodePNGInfo.


5. Кодирование
---------- -

Кодирование преобразует буфер необработанных пикселей в сжатое изображение PNG.

Большая часть документации по использованию кодировщика находится в его объявлениях в заголовке.
выше.Для C простое кодирование может быть выполнено с помощью таких функций, как
lodepng_encode32, а более сложное декодирование можно выполнить с помощью struct
LodePNGState и lodepng_encode.Для C ++ все кодирование может быть выполнено с помощью
различные функции lodepng::encode и lodepng::State могут использоваться для расширенных
Особенности.

Как и декодер, кодировщик также может выдавать ошибки.Однако дает меньше ошибок
поскольку вход кодера является надежным, вход декодера(изображение PNG, которое может
    быть подделанным кем - либо) не верится.

    При использовании LodePNGState для кодирования используются следующие поля :
*) LodePNGInfo info_png : здесь вы указываете, каким должен быть PNG(вывод).
*) LodePNGColorMode info_raw : здесь вы указываете, какой цветовой тип необработанного изображения(вход) имеет
*) Кодировщик LodePNGEncoderSettings : вы можете указать несколько настроек для использования кодировщиком

LodePNGInfo info_png
--------------------

При кодировании вы используете это противоположно тому, как при декодировании : для кодирования,
вы заполняете значения, которые хотите, чтобы PNG имел перед кодированием.По умолчанию это
не нужно указывать тип цвета для PNG, так как он выбирается автоматически,
но его можно выбрать самостоятельно при правильных настройках.

Кодировщик не всегда будет точно соответствовать предоставленной вами структуре LodePNGInfo,
он старается как можно ближе.Некоторые вещи кодировщик игнорирует.В
кодировщик использует, например, следующие настройки из него, когда это применимо :
тип цвета и глубина цвета, фрагменты текста, фрагменты времени, цветовой ключ, палитра,
цвет фона, метод чересстрочной развертки, неизвестные фрагменты, ...

При кодировании в PNG с типом цвета 3 кодировщик сгенерирует блок PLTE.
Если палитра содержит какие - либо цвета, для которых альфа - канал не равен 255 (так
    в палитре есть полупрозрачные цвета), он добавит кусок tRNS.

    LodePNGColorMode info_raw
    ------------------------ -

    Здесь вы указываете тип цвета необработанного изображения, которое вы даете входу,
    включая возможный прозрачный цветовой ключ и палитру, которую вы используете в
    ваши необработанные данные изображения.

    По умолчанию предполагается 32 - битный цвет, то есть ваш ввод должен быть в формате RGBA.
    формат с 4 байтами(беззнаковые символы) на пиксель.

    Кодировщик LodePNGEncoderSettings
    ------------------------------

    Поддерживаются следующие настройки(некоторые находятся в подструктурах) :
    *) auto_convert: когда эта опция включена, кодировщик будет
    автоматически выбирает минимально возможный цветовой режим(включая цветовой ключ), который
    может кодировать цвета всех пикселей без потери информации.
    *) btype: тип блока для LZ77. 0 = без сжатия, 1 = фиксированное дерево Хаффмана,
    2 = динамическое дерево Хаффмана(наилучшее сжатие).Должно быть 2 для правильного
    сжатие.
    *) use_lz77: следует ли использовать LZ77 для сжатых типов блоков.Должно быть
    верно для правильного сжатия.
    *) windowsize: размер окна, используемый кодировщиком LZ77(1 - 32768).Имеет ценность
    По умолчанию 2048, но можно установить 32768 для лучшего, но медленного сжатия.
    *) force_palette: если тип цвета 2 или 6, вы можете заставить кодировщик писать PLTE
    чанк, если force_palette истинно.Это можно использовать в качестве предлагаемой палитры для преобразования
    для зрителей, которые не поддерживают более 256 цветов(если они еще существуют)
    *) add_id: добавить к изображению фрагмент текста «Encoder : LodePNG <version>».
    *) text_compression: по умолчанию 1. Если 1, текст будет сохраняться как zTXt вместо фрагментов tEXt.
    Фрагменты zTXt используют сжатие текста zlib.Это дает меньший результат на
    большие тексты, но больший результат для небольших текстов(например, одно имя программы).
    Это все tEXt или все zTXt, хотя отдельной настройки для текста пока нет.


    6. преобразование цвета
    --------------------

    Важно отметить, что в LodePNG цветовой тип PNG и
    цветовой тип необработанного изображения полностью независим.По умолчанию, когда
    вы декодируете PNG, вы получаете результат в виде необработанного изображения нужного вам цветового типа,
    независимо от того, был ли PNG закодирован с помощью палитры, оттенков серого или цвета RGBA.
    А если вы закодируете изображение, по умолчанию LodePNG автоматически выберет PNG.
    тип цвета, обеспечивающий хорошее сжатие в зависимости от значений цветов и количества
    цветов в изображении.Его можно настроить так, чтобы вы могли управлять им как
    ну хотя.

    Для этого LodePNG выполняет преобразование из одного цветового режима в другой.
    Он может преобразовывать практически любой цветовой тип в любой другой цветовой тип, кроме
    следующие преобразования : RGB в оттенки серого не поддерживается, а преобразование в
    палитра, когда в палитре нет требуемого цвета, не поддерживается.Это
    не поддерживается намеренно : это потеря информации, требующая цвета
    алгоритм уменьшения, который выходит за рамки кодировщика PNG(да, RGB в серый
        это просто, но есть несколько способов, чтобы дать некоторым каналам больше
        масса).

    По умолчанию при декодировании вы получаете необработанное изображение в 32 - битном RGBA или 24 - битном RGB.
    цвет, независимо от того, какой цветовой тип имеет PNG.И по умолчанию при кодировании
    LodePNG автоматически выбирает лучшую цветовую модель для выходного PNG и ожидает
    входное изображение должно быть 32 - битным RGBA или 24 - битным RGB.Итак, если вы не хотите контролировать
    цветовой формат изображений, вы можете пропустить эту главу.

    6.1.Типы цветов PNG
    --------------------

    Изображение PNG может иметь много цветовых типов, от 1 - битного до 64 - битного цвета,
    а также цветовые режимы с палитрой.После декомпрессии и нефильтрации zlib
    в PNG - изображении необработанные пиксельные данные будут иметь этот цветовой тип и, следовательно,
    определенное количество бит на пиксель.Если вы хотите, чтобы необработанное изображение выводилось после
    декодирования для получения другого цветового типа преобразование выполняется LodePNG.

    Спецификация PNG дает следующие цветовые типы :

0 : оттенки серого, битовая глубина 1, 2, 4, 8, 16
2 : RGB, битовая глубина 8 и 16
3 : палитра, битовая глубина 1, 2, 4 и 8
4 : оттенки серого с альфа - каналом, битовая глубина 8 и 16
6 : RGBA, битовая глубина 8 и 16

Битовая глубина - это количество битов на пиксель на цветовой канал.Итак, общая сумма
бит на пиксель : количество каналов* битовая глубина.

6.2.преобразование цвета
----------------------

Как объясняется в разделах о кодировщике и декодере, вы можете указать
типы цвета и битовая глубина в info_png и info_raw, чтобы изменить значение по умолчанию
поведение.

Если при декодировании вы хотите, чтобы исходное изображение отличалось от значения по умолчанию,
вам нужно установить желаемый тип цвета и битовую глубину в LodePNGColorMode,
или параметры colortype и bitdepth простой функции декодирования.

Если при кодировании вы используете другой цветовой тип, отличный от значения по умолчанию в исходном вводе
изображения, вам необходимо указать его цветовой тип и битовую глубину в LodePNGColorMode
необработанного изображения или используйте параметры colortype и bitdepth простого
функция кодирования.

Если при кодировании вы не хотите, чтобы LodePNG выбирал выходной цветовой тип PNG
но управляйте им самостоятельно, вам нужно установить auto_convert в настройках кодировщика
значение false и укажите нужный тип цвета в LodePNGInfo
кодировщик(включая палитру : он может генерировать палитру, если auto_convert истинно,
    иначе нет).

    Если тип цвета ввода и вывода различается(выбран пользователем или выбран автоматически),
    LodePNG выполнит преобразование цвета в соответствии с приведенными ниже правилами и может
    иногда приводит к ошибке.

    Чтобы избежать путаницы :
-декодер конвертирует из PNG в необработанное изображение
- кодер преобразует необработанное изображение в PNG
- тип цвета и битовая глубина в LodePNGColorMode info_raw соответствуют необработанному изображению
- тип цвета и битовая глубина в цветовом поле LodePNGInfo info_png соответствуют PNG
- при кодировании тип цвета в LodePNGInfo игнорируется, если auto_convert
включен, он автоматически генерируется вместо
- при декодировании тип цвета в LodePNGInfo устанавливается декодером на исходный
PNG изображение, но его можно игнорировать, так как исходное изображение имеет тип цвета, который вы запрашивали вместо этого.
- если цветовой тип изображения LodePNGColorMode и PNG не совпадает, преобразование
между цветовыми типами выполняется, если цветовые типы поддерживаются.Если это не так
поддерживается, возвращается ошибка.Если типы совпадают, преобразование не выполняется.
- Несмотря на то, что некоторые преобразования не поддерживаются, LodePNG поддерживает загрузку PNG из любых
colortype и сохранение PNG в любой цветовой тип, иногда просто требуется подготовка
необработанное изображение правильно перед кодированием.
- и кодировщик, и декодер используют один и тот же преобразователь цвета.

Функция lodepng_convert выполняет преобразование цвета.Он доступен в
интерфейс, но обычно не требуется, поскольку кодировщик и декодер уже вызывают
Это.

Неподдерживаемые преобразования цвета :
-цвет в оттенки серого, если присутствуют не серые пиксели : ошибка не выдается, но
результат будет выглядеть некрасиво, потому что берется только красный канал(предполагается, что все
    в этом случае три канала одинаковы, поэтому игнорируются зеленый и синий).Причина
    ошибка не дается, чтобы разрешить преобразование трехканальных изображений в оттенках серого в
    одноканальный, даже если есть числовые неточности.
    - все, что есть в палитре, когда палитра не имеет точного соответствия исходному цвету
    в нем : в этом случае выдается ошибка

    Поддерживаемые преобразования цвета :
-все до 8 - битного RGB, 8 - битного RGBA, 16 - битного RGB, 16 - битного RGBA
- Любой серый или серый + альфа, до серого или серого + альфа
- все что угодно в палитре, если в палитре есть требуемые цвета
- удаление альфа - канала
- выше к меньшей битовой глубине и наоборот

Если вы не хотите, чтобы преобразование цвета выполнялось(например, для скорости или контроля) :
    -В кодировщике вы можете сохранить PNG с любым цветовым типом, указав
    необработанный цветовой режим и LodePNGInfo - тот же цветовой режим, а для параметра auto_convert установлено значение
    ложный.
    - В декодере вы можете заставить его хранить данные пикселей в том же цвете
    как и PNG, установив для параметра color_convert значение false.Настройки в
    info_raw тогда игнорируются.

    6.3.биты заполнения
    ---------------- -

    В формате файла PNG, если используется цветовой тип менее 8 бит на пиксель и строки развертки
    имеют битовое количество, не кратное 8, тогда используются биты заполнения, так что каждый
    строка сканирования начинается со нового байта.Но это НЕ верно для необработанного ввода и вывода LodePNG.
    Необработанное входное изображение, которое вы передаете кодировщику, и исходное выходное изображение, которое вы получаете от декодера.
    НЕ будет иметь этих битов заполнения, например, в случае 1 - битного изображения с шириной
    из 7 пикселей первый пиксель второй строки развертки будет 8 - м битом первого байта,
    не первый бит нового байта.

    6.4.Замечание о 16 битах на канал и порядке байтов
    -------------------------------------------------- -

    LodePNG также использует массивы беззнаковых символов для 16 - битных цветов на канал, как и
    для любого другого цветового формата. 16 - битные значения хранятся с прямым порядком байтов(большинство
        значимый байт первым) в этих массивах.Это обратный порядок
    little endian используется процессорами x86.

    LodePNG всегда использует прямой порядок байтов, потому что формат файла PNG имеет внутреннее значение.
    Преобразования в форматы, отличные от PNG, которые используются внутри компании, не поддерживаются
    LodePNG специально существует множество форматов, включая порядок байтов 16 - битных
    цвета, порядок, в котором вы храните R, G, B и A, и так далее.Поддержка и
    преобразование в / из всего, что выходит за рамки LodePNG.

    Это может означать, что в зависимости от вашего варианта использования вы можете захотеть преобразовать большой
    endian вывод LodePNG в прямой порядок байтов с циклом for.Это уж точно не
    всегда нужны, многие приложения и библиотеки поддерживают 16 - битные цвета с прямым порядком байтов
    в любом случае, но это означает, что вы не можете просто преобразовать буфер unsigned char* в
    беззнаковый короткий буфер* на процессорах x86.


    7. значения ошибок
    -------------- -

    Все функции в LodePNG, которые возвращают код ошибки, возвращают 0, если все прошло
    ОК, или ненулевой код, если произошла ошибка.

    Значение ошибок LodePNG можно получить с помощью функции
    lodepng_error_text : с учетом числового кода ошибки возвращает описание
    ошибки на английском языке в виде строки.

    Проверьте реализацию lodepng_error_text, чтобы увидеть значение каждого кода.

    Не рекомендуется использовать числовые значения для программного создания
    различные решения, основанные на типах ошибок, поскольку числа не гарантируются
    сохранять обратную совместимость.Они предназначены только для потребления человеком.Программно
    только 0 или не 0 имеет значение.


    8. куски и редактирование PNG
    ------------------------ -

    Если вы хотите добавить дополнительные фрагменты в кодируемый вами PNG, или используйте LodePNG для PNG
    редактор, который должен следовать правилам обработки неизвестных фрагментов, или если ваш
    программа может читать блоки других типов, кроме тех, которые обрабатываются LodePNG,
    тогда это возможно с помощью функций фрагментов LodePNG.

    Чанк PNG имеет следующий макет :

Длина 4 байта
4 байта имя типа
длина байтов данных
4 байта CRC

8.1.итерация по кускам
---------------------------- -

Если у вас есть буфер, содержащий данные изображения PNG, тогда первый фрагмент(
    Блок IHDR) начинается с байта номер 8 этого буфера.Первые 8 байтов - это
    подпись PNG и не являются частью чанка.Но если вы начнете с байта 8
    тогда у вас есть кусок, и вы можете проверить его следующее.

    ПРИМЕЧАНИЕ: ни одна из этих функций не проверяет границы буфера памяти.Избегать
    эксплойты, всегда проверяйте, чтобы буфер содержал все данные фрагментов.
    При использовании lodepng_chunk_next убедитесь, что возвращаемое значение находится в пределах
    выделенная память.

    беззнаковый lodepng_chunk_length(const unsigned char* chunk) :

    Получите длину данных блока.Общая длина блока равна этой длине + 12.

    void lodepng_chunk_type(char type[5], const unsigned char* chunk) :
    unsigned char lodepng_chunk_type_equals(const unsigned char* chunk, const char* type) :

    Получите тип чанка или сравните, если это определенный тип

    unsigned char lodepng_chunk_critical(const unsigned char* chunk) :
    unsigned char lodepng_chunk_private(const unsigned char* chunk) :
    unsigned char lodepng_chunk_safetocopy(const unsigned char* chunk) :

    Проверьте, является ли блок критичным в стандарте PNG(только IHDR, PLTE, IDAT и IEND).
    Проверьте, является ли фрагмент частным(общедоступные фрагменты являются частью стандарта, а частные - нет).
    Проверьте, можно ли копировать фрагмент.Если это не так, то при изменении данных в критическом
    фрагмент, небезопасный для копирования фрагментов старого изображения, НЕ может быть сохранен в новом, если ваш
    программа не обрабатывает этот тип неизвестного фрагмента.

    unsigned char* lodepng_chunk_data(unsigned char* chunk) :
    const unsigned char* lodepng_chunk_data_const(const unsigned char* chunk) :

    Получите указатель на начало данных чанка.

    беззнаковый lodepng_chunk_check_crc(const unsigned char* chunk) :
    void lodepng_chunk_generate_crc(unsigned char* chunk) :

    Проверьте правильность CRC или создайте правильный.

    unsigned char* lodepng_chunk_next(unsigned char* chunk) :
    const unsigned char* lodepng_chunk_next_const(const unsigned char* chunk) :

    Перейти к следующему фрагменту.Это работает, если у вас есть буфер с последовательными фрагментами.Обратите внимание, что эти
    функции вообще не проверяют границы выделенных данных, поэтому убедитесь, что их достаточно
    данные, доступные в буфере, чтобы иметь возможность перейти к следующему фрагменту.

    беззнаковый lodepng_chunk_append(unsigned char** out, size_t * outize, const unsigned char* chunk) :
    беззнаковый lodepng_chunk_create(unsigned char** out, size_t * outize, беззнаковая длина,
        const char* type, const unsigned char* data) :

    Эти функции используются для создания новых фрагментов, которые добавляются к данным in* out, у которых есть
    длина* негабарит.Функция добавления добавляет существующий фрагмент к новым данным.Создание
    функция создает новый чанк с заданными параметрами и добавляет его.Тип - 4 - х буквенный
    имя чанка.

    8.2.куски в info_png
    ---------------------- -

    Структура LodePNGInfo содержит поля с неизвестным фрагментом.Имеет 3
    буферы(каждый с размером), чтобы содержать 3 типа неизвестных блоков :
те, которые идут перед блоком PLTE, те, которые идут между PLTE
и блоки IDAT, и те, которые идут после блоков IDAT.
Необходимо различать эти 3 случая, потому что PNG
стандартные силы для сохранения порядка неизвестных фрагментов по сравнению с критическими
чанков, но не применяет никаких других правил упорядочивания.

info_png.unknown_chunks_data[0] - фрагменты перед PLTE
info_png.unknown_chunks_data[1] - фрагменты после PLTE, до IDAT
info_png.unknown_chunks_data[2] - фрагменты после IDAT

Чанки в этих 3 буферах можно перебирать и читать, используя один и тот же
способом, описанным в предыдущем подразделе.

При использовании декодера для декодирования PNG вы можете заставить его хранить все неизвестные фрагменты
если вы установите для параметра settings.remember_unknown_chunks значение 1. По умолчанию это
опция выключена(0).

Кодировщик всегда будет кодировать неизвестные фрагменты, которые хранятся в info_png.
Если вам нужно добавить определенный фрагмент, который не известен LodePNG, вы можете
используйте lodepng_chunk_append или lodepng_chunk_create для данных блока в
info_png.unknown_chunks_data[x].

Чанки, известные LodePNG, не должны добавляться таким образом.Например, чтобы сделать
LodePNG добавляет блок bKGD, устанавливает для background_defined значение true и добавляет правильный
параметры там вместо этого.


9. поддержка компилятора
------------------ -

Никаких других библиотек, кроме текущей стандартной библиотеки C, не требуется для компиляции.
LodePNG.Для версии C ++ сверху нужна только стандартная библиотека C++.
Добавьте в проект файлы lodepng.c(pp) и lodepng.h, включая
lodepng.h там, где это необходимо, и ваша программа может читать / записывать файлы PNG.

Он совместим с C90 и выше, а также с C++ 03 и выше.

Если важна производительность, используйте оптимизацию при компиляции!Для обоих
кодировщик и декодер, это имеет большое значение.

Убедитесь, что LodePNG скомпилирован одним и тем же компилятором той же версии.
и с теми же настройками, что и остальная программа, или интерфейсы с
std::vectors и std::strings в C ++ могут быть несовместимы.

CHAR_BITS должен быть 8 или выше, потому что LodePNG использует беззнаковые символы для октетов.

*) gcc и g ++

LodePNG разработан в gcc, поэтому этот компилятор изначально поддерживается.Это не дает
предупреждения с параметрами компилятора "-Wall -Wextra -pedantic -ansi", с gcc и g ++
версия 4.7.1 в Linux, 32 - битная и 64 - битная.

*) Лязг

Полностью поддерживается и без предупреждений.

*) Mingw

Компилятор Mingw(порт gcc для Windows) должен полностью поддерживаться
LodePNG.

*) Visual Studio и Visual C ++ Express Edition

LodePNG должен быть без предупреждений с уровнем предупреждения W4.Два предупреждения были отключены
с прагмами : предупреждение 4244 о неявных преобразованиях и предупреждение 4996
где он хочет использовать нестандартную функцию fopen_s вместо стандартной C
fopen.

Visual Studio может захотеть включить файлы stdafx.h в каждый исходный файл и
выдает ошибку «неожиданный конец файла при поиске предварительно скомпилированного заголовка».
Это не стандартный C++, и он не будет добавлен в стандартный LodePNG.Вы можете
отключите его для lodepng.cpp, только щелкнув его правой кнопкой мыши, Свойства, C / C++,
Предварительно скомпилированные заголовки и установите для него значение «Не использовать предварительно скомпилированные заголовки».

ПРИМЕЧАНИЕ.Современные версии VS должны полностью поддерживаться, но старые версии, например
VS6, работа не гарантируется.

*) Компиляторы на Macintosh

Сообщается, что LodePNG работает как с gcc, так и с LLVM для Macintosh, как для
C и C++.

*) Другие компиляторы

Если у вас возникнут проблемы с какими - либо компиляторами, дайте мне знать, и я могу
попробуйте исправить это, если компилятор современный и соответствует стандартам.


10. примеры
------------

Этот пример декодера показывает самое простое использование LodePNG.Более сложный
примеры можно найти на сайте LodePNG.

ПРИМЕЧАНИЕ: эти примеры не поддерживают имена файлов с расширенными символами, вы можете использовать
внешний метод для обработки таких файлов и кодирования или декодирования в памяти

10.1.пример декодера C++
------------------------ -

#include "lodepng.h"
#include <iostream>

int main(int argc, char* argv[]) {
    const char* filename = argc > 1 ? argv[1] : "test.png";

    // загружаем и декодируем
    std::vector <unsigned char> image;
    беззнаковая ширина, высота;
    беззнаковая ошибка = lodepng::decode(изображение, ширина, высота, имя файла);

    // если есть ошибка, отобразить ее
    if (error) std::cout << "ошибка декодера" << error << ":" << lodepng_error_text(error) << std::endl;

    // пиксели теперь находятся в векторном "изображении", 4 байта на пиксель, упорядоченный RGBARGBA ..., использовать его как текстуру, нарисовать, ...
}

10.2.пример декодера C
---------------------- -

#include "lodepng.h"

int main(int argc, char* argv[]) {
    беззнаковая ошибка;
    беззнаковый символ* изображение;
    size_t ширина, высота;
    const char* filename = argc > 1 ? argv[1] : "test.png";

    error = lodepng_decode32_file(&изображение, &ширина, &высота, имя файла);

    if (error) printf("ошибка декодера% u:% s \ n", error, lodepng_error_text(error));

    / *здесь используйте изображение * /

        бесплатно(изображение);
    возврат 0;
}

11. справочник по настройкам состояния
----------------------------

Краткий справочник по некоторым настройкам LodePNGState

Для расшифровки :

state.decoder.zlibsettings.ignore_adler32 : игнорировать контрольные суммы ADLER32
state.decoder.zlibsettings.custom _... : использовать настраиваемую функцию надувания
state.decoder.ignore_crc : игнорировать контрольные суммы CRC
state.decoder.ignore_critical : игнорировать неизвестные критические блоки
state.decoder.ignore_end : игнорировать отсутствующий блок IEND.Может выйти из строя, если это повреждение вызовет другие ошибки
state.decoder.color_convert : преобразовать внутренний цвет PNG в выбранный
state.decoder.read_text_chunks : следует ли читать фрагменты текстовых метаданных
state.decoder.remember_unknown_chunks : следует ли читать неизвестными фрагментами
state.info_raw.colortype : желаемый тип цвета для декодированного изображения
state.info_raw.bitdepth : желаемая битовая глубина для декодированного изображения
state.info_raw .... : дополнительные настройки цвета см.в struct LodePNGColorMode
state.info_png .... : нет настроек для декодера, но вывод, см. struct LodePNGInfo

Для кодирования :

state.encoder.zlibsettings.btype : отключите сжатие, установив для него значение 0
state.encoder.zlibsettings.use_lz77 : использовать LZ77 при сжатии
state.encoder.zlibsettings.windowsize : настроить размер окна LZ77
state.encoder.zlibsettings.minmatch : настроить минимальную длину LZ77 для соответствия
state.encoder.zlibsettings.nicematch : настроить соответствие LZ77, где прекратить поиск
state.encoder.zlibsettings.lazymatching : попробуйте еще одно сопоставление LZ77
state.encoder.zlibsettings.custom _... : использовать пользовательскую функцию deflate
state.encoder.auto_convert : выберите оптимальный цветовой тип PNG, если 0 использует info_png
state.encoder.filter_palette_zero : Стратегия фильтрации PNG для палитры
state.encoder.filter_strategy : Стратегия фильтрации PNG для кодирования с помощью
state.encoder.force_palette : добавить палитру, даже если она не кодируется
state.encoder.add_id : добавить идентификатор и версию LodePNG в виде фрагмента текста
state.encoder.text_compression : использовать сжатые фрагменты текста для метаданных
state.info_raw.colortype : тип цвета исходного входного изображения, которое вы предоставляете
state.info_raw.bitdepth : битовая глубина исходного входного изображения, которое вы предоставляете
state.info_raw : дополнительные настройки цвета, см. struct LodePNGColorMode
state.info_png.color.colortype : желаемый тип цвета, если auto_convert имеет значение false
state.info_png.color.bitdepth : желаемая битовая глубина, если auto_convert имеет значение false
state.info_png.color .... : дополнительные настройки цвета см.в struct LodePNGColorMode
state.info_png .... : дополнительные настройки, связанные с PNG, см. struct LodePNGInfo


12. изменения
---------- -

Номер версии LodePNG - это дата изменения, указанная в формате
ггггммдд.

Некоторые изменения не имеют обратной совместимости.Они обозначены(!)
условное обозначение.

Здесь перечислены не все изменения, в истории коммитов в github указано больше :
https://github.com/lvandeve/lodepng

*) 27 июн 2021: добавлены предупреждения о том, что функции чтения / записи файлов не поддерживают
имена файлов с расширенными символами(поддержка этого не планируется, открытие файлов
    не является основной частью декодирования / декодирования PNG и зависит от платформы).
    *) 17 окт 2020: по умолчанию запрещать декодирование слишком больших фрагментов текста / icc.
    *) 06 марта 2020 г .: упрощены некоторые распределения динамической памяти.
    *) 12 янв 2020: (!) Добавлен аргумент end в lodepng_chunk_next, чтобы разрешить
    проверки переполнения.
    *) 14 августа 2019 г .: декодирование примерно на 25 % быстрее благодаря таблицам поиска Хаффмана.
    *) 15 июн 2019: (!) Изменен API auto_choose_color(для исправления : не использовать палитру
        если серый профиль ICC) и не - ICC LodePNGColorProfile переименован в
    LodePNGColorStats.
    *) 30 декабря 2018: изменения только стиля кода : удалены символы новой строки перед открывающими фигурными скобками.
    *) 10 сен 2018: добавлен способ проверки блоков метаданных без полного декодирования.
    *) 19 авг 2018: (!) Фиксированный цветовой режим bKGD закодирован и заставил его использовать
    индекс палитры в случае палитры.
    *) 10 авг 2018: (!) Добавлена ​​поддержка чанков gAMA, cHRM, sRGB и iCCP.Этот
    change имеет обратную совместимость, если вы не полагались на unknown_chunks для них.
    *) 11 июн 2018: менее строгая проверка на переполнение целочисленного размера пикселя
    *) 14 янв 2018: разрешить опционально игнорировать еще несколько исправимых ошибок
    *) 17 сен 2017: исправлена ​​утечка памяти для некоторых случаев ошибок ввода кодировщика
    *) 27 ноя 2016: исправление ошибки автоматического определения цветовой модели серый + альфа
    *) 18 апр 2016: Изменен qsort на нестандартную стабильную сортировку(для платформ без qsort).
    *) 09 апр 2016: Исправлено определение использования цветовой клавиши и улучшена загрузка файлов(в пределах
    пределы чистого C90).
    *) 08 дек 2015: Добавлена ​​ошибка, при которой функция load_file возвращает ошибку, если файл не открывается.
    *) 24 окт 2015: Исправление с декодированием в вывод палитры.
    *) 18 апр 2015: Граничная PM вместо простого слияния пакетов для более быстрого кодирования.
    *) 24 авг 2014: перенесено на github
    *) 23 авг 2014: Уменьшено ненужное использование памяти декодером.
    *) 28 июн 2014: Удалена настройка fix_png, всегда поддерживает палитру OOB для
    простота.ColorProfile стал общедоступным.
    *) 09 июн 2014: Более быстрый кодировщик за счет исправления хеш - ошибки и большей оптимизации нулей.
    *) 22 декабря 2013: Для оптимизации требуется мощность двух окон.
    *) 15 апр 2013: Исправлена ​​ошибка с LAC_ALPHA и цветовым ключом.
    *) 25 марта 2013: Добавлена ​​дополнительная возможность игнорировать некоторые ошибки PNG(fix_png).
    *) 11.03.2013: (!) Исправление с кастомным бесплатным.Изменено с "my" на "lodepng_"
    префикс для пользовательских распределителей и сделал это возможным с новым #define для
    используйте собственные в своем проекте без необходимости изменять код lodepng.
    *) 28 янв 2013: Исправление с цветовым ключом.
    *) 27 окт 2012: Доработана обработка ошибок длины ключевого слова в текстовом блоке.
    *) 8 окт 2012: (!) Добавлена ​​новая стратегия фильтрации(энтропия) и новый режим автоцвета.
    (без палитры).Лучшее кодирование дерева deflate.Новые настройки сжатия.
    Более быстрое преобразование цветов при декодировании.Некоторые внутренние чистки.
    *) 23 сен 2012: Немного уменьшено количество предупреждений в Visual Studio.
    *) 1 сен 2012: (!) Удалено # определение для предоставления пользовательских(де) функций сжатия
    и вместо этого заставил его работать с указателями на функции.
    *) 23 июн 2012: Добавлено больше стратегий фильтрации.Упрощено использование настраиваемого выделения
    и бесплатные функции и переключение #defines из флагов компилятора.Небольшие исправления.
    *) 6 мая 2012: (!) Сделано подключение пользовательских функций zlib / deflate более гибким.
    *) 22 апр 2012: (!) Интерфейс стал более согласованным, много переименований.Удаленный
    избыточные классы кодека C++.Уменьшено количество структур.Все изменилось,
    но теперь он чище, imho, и функциональность осталась прежней.Также исправлено
    несколько ошибок и сжал код реализации.Изготовлены новые образцы.
    *) 6 ноя 2011: (!) По умолчанию кодировщик теперь автоматически выбирает лучшее
    Цветовая модель PNG и битовая глубина в зависимости от количества и типа цветов
    необработанное изображение.Для этого autoLeaveOutAlphaChannel заменен на auto_choose_color.
    *) 9 окт 2011: более простая реализация хеш - цепочки для кодировщика.
    *) 8 сен 2011: ленивое сопоставление кодировщика lz77 вместо жадного сопоставления.
    *) 23 августа 2011: изменены параметры сжатия zlib после тестирования.
    Исправлена ​​ошибка с эвристикой типа фильтра PNG, так что она выбирает много
    лучшие(это весьма существенно).Настройка для экспериментального, медленного,
    Добавлен перебор типов фильтров PNG.
    *) 17 авг 2011: (!) Изменены имена некоторых функций, связанных с C zlib.
    *) 16 августа 2011: сделали код менее широким(максимум 120 символов в строке).
    *) 17 апреля 2011 г .: очистка кода.Исправление ошибок.Преобразуйте низкие цвета в 16 - битные на образец цвета.
    *) 21 feb 2011: исправлена ​​компиляция для C90.Исправлена ​​компиляция с отключенными секциями.
    *) 11 дек 2010: кодирование стало быстрее, по предложению Питера Истмана
    для оптимизации длинных последовательностей нулей.
    *) 13 ноя 2010: добавлены LodePNG_InfoColor_hasPaletteAlpha и
    LodePNG_InfoColor_canHaveAlpha функции для удобства.
    *) 7 ноя 2010: добавлена ​​функция LodePNG_error_text для получения описания кода ошибки.
    *) 30 окт 2010: сделана расшифровка немного быстрее
    *) 26 окт 2010: (!) Изменены имена некоторых функций и структур C(более согласованные).
    Реорганизовал документацию и порядок объявления в шапке.
    *) 08 авг 2010: изменены только некоторые комментарии и внешние образцы.
    *) 05 июл 2010: исправлена ​​ошибка, связанная с предупреждениями в новой версии gcc.
    *) 14 марта 2010: исправлена ​​ошибка, при которой под буферы символов выделялось слишком много памяти.
    *) 02 сен 2008: исправлена ​​ошибка, при которой могло создаваться пустое дерево, которое могли использовать приложения linux.
    читайте, игнорируя проблему, но приложения Windows не могли.
    *) 06 июн 2008: добавлены дополнительные проверки ошибок для случаев нехватки памяти.
    *) 26 апр 2008: добавлено еще несколько проверок кое - где для большей безопасности.
    *) 06.03.2008: исправлен вылет при кодировании строк
    *) 02 фев 2008: добавлена ​​поддержка международных текстовых блоков(iTXt)
    *) 23 января 2008 г .: небольшие подчистки и # определение разделения кода на разделы.
    *) 20 января 2008: поддержка неизвестных чанков, позволяющая использовать LodePNG в качестве редактора.
    *) 18 января 2008: добавлена ​​поддержка блоков времени и pHYs в кодировщик и декодер.
    *) 17.01.2008: добавлена ​​возможность кодирования и декодирования сжатых блоков zTXt
    Также различные исправления, например, в коде deflate и padding битов.
    *) 13 янв 2008: Добавлена ​​возможность кодирования изображений с чересстрочной разверткой Adam7.Улучшен
    код фильтрации кодировщика.
    *) 07 янв 2008: (!) Изменил LodePNG на использование ISO C90 вместо C++.А
    Обертка C ++ вокруг этого предоставляет интерфейс, почти идентичный предыдущему.
    Наличие в LodePNG чистого ISO C90 делает его более портативным.Код C и C ++
    находятся вместе в этих файлах, но работает как для компиляторов C, так и для C++.
    *) 29 дек 2007: (!) Большинство целочисленных типов заменено на unsigned int + другие настройки
    *) 30 августа 2007: исправлена ​​ошибка, делающая этот Borland C ++ совместимым.
    *) 09 августа 2007: некоторые предупреждения VS2005 снова удалены
    *) 21 июля 2007: код дефляции помещен в новое пространство имен отдельно от кода zlib
    *) 08 июн 2007: исправлена ​​ошибка с 2 - и 4 - битным цветом и маленькими чересстрочными изображениями.
    *) 04 июн 2007: улучшенная поддержка Visual Studio 2005 : сбой при доступе
    исправлен недопустимый элемент std::vector[0], а предупреждения уровня 3 и 4 удалены
    *) 02 июн 2007: заставил кодировщик добавлять тег с версией по умолчанию
    *) 27 мая 2007 г .: коды zlib и png разделены(но все еще в одном файле),
    добавлены простые функции кодировщика / декодера для более простых случаев использования
    *) 19 мая 2007: мелкие исправления, некоторая чистка кода, добавлена ​​новая ошибка(ошибка 69),
    переместил некоторые примеры отсюда в lodepng_examples.cpp
    *) 12 мая 2007: исправлена ​​ошибка декодирования палитры
    *) 24 апр 2007: изменена лицензия с BSD на лицензию zlib.
    *) 11.03.2007: очень простое дополнение : возможность кодировать чанки bKGD.
    *) 04.03.2007: (!) Исправления, связанные с текстовыми чанками, и поддержка кодирования
    палитры изображений PNG.Плюс небольшое изменение интерфейса с палитрой и текстами.
    *) 03 марта 2007: Сделано кодирование динамического Хаффмана более коротким с повторяющимися кодами.
    Исправлена ​​ошибка, из - за которой конечный код блока имел длину 0 в дереве Хаффмана.
    *) 26 фев 2007: теперь реализовано сжатие Хаффмана с динамическими деревьями(BTYPE 2).
    и поддерживается кодировщиком, что приводит к уменьшению размера PNG на выходе.
    *) 27 января 2007: Ускорен тест Adler - 32, чтобы не было потерь времени.
    *) 24 янв 2007: выдал кодировщику интерфейс ошибки.Добавлена ​​конвертация цвета из любого
    Тип шкалы серого в 8 - битную шкалу серого с альфа - каналом или без него.
    *) 21.01.2007: (!) Полностью изменен интерфейс.Это позволяет больше цветотипов
    преобразовать в и является более однородным.См.Руководство, чтобы узнать, как это работает сейчас.
    *) 07 янв 2007: Некоторые исправления и исправления, а также несколько изменений за последние дни :
    кодировать / декодировать пользовательские фрагменты текста, отдельные классы для zlib и deflate и
        наконец - то заставил декодер выдавать ошибки для некорректного Adler32 или Crc.
        *) 01 января 2007: Исправлена ​​ошибка кодирования PNG с менее чем 8 битами на канал.
        *) 29 декабря 2006: Добавлена ​​поддержка кодирования изображений без альфа - канала и
        очистил код, а также сделал некоторые части быстрее.
        *) 28.12.2006: В кодировщик добавлены "Настройки".
        *) 26 дек 2006: Кодировщик теперь выполняет кодирование LZ77 и теперь производит файлы гораздо меньшего размера.
        Убрано некоторое дублирование кода в декодере.Исправлена ​​небольшая ошибка в примере.
        *) 09 дек 2006: (!) В качестве первого параметра помещены выходные параметры публичных функций.
        Исправлена ​​ошибка декодера с 16 бит на цвет.
        *) 15 окт 2006: Изменена структура документации.
        *) 09 окт 2006: Добавлен класс Encoder.Он кодирует допустимое изображение PNG из
        данный буфер изображения, однако пока он не сжат.
        *) 08 сен 2006: (!) Изменен интерфейс с классом Decoder
        *) 30 июл 2006: (!) LodePNG_InfoPng, ширина и высота теперь извлекаются в разных
        способ.DecodePNG переименован в decodePNGGeneric.
        *) 29 июл 2006: (!) Изменен интерфейс : информация об изображении теперь возвращается в виде
        структура типа LodePNG::LodePNG_Info вместо вектора, что было немного неуклюже.
        *) 28 июл 2006: Исправлен код и добавлены новые проверки ошибок.
        Исправлена ​​терминология «сдуть» на «надуть».
        *) 23 июн 2006: Добавлен пример SDL в документацию в шапке, это
        Пример позволяет легко отладить, отображая PNG и его прозрачность.
        *) 22.06.2006: (!) Изменен способ получения значения ошибки.Добавлен
        loadFile для удобства.DecodePNG32 стал быстрее.
        *) 21.06.2006: (!) Изменен тип информационного вектора на беззнаковый.
        Изменено положение палитры в информационном векторе.Исправлена ​​важная ошибка, которая
        произошло с PNG с несжатым блоком.
        *) 16 июня 2006 г .: внутренне беззнаковое заменено на беззнаковое, где
        необходимо, и выполнил некоторые оптимизации.
        *) 07 июн 2006: (!) Функции переименованы в decodePNG и размещены
        в пространстве имен LodePNG.Изменен порядок параметров.Переписал
        документация в шапке.Файлы переименованы в lodepng.cpp и lodepng.h
        *) 22 апреля 2006: Оптимизирован и улучшен некоторый код.
        *) 07 сен 2005: (!) Изменен интерфейс на std::vector
        *) 12 августа 2005 г .: первый выпуск(C++, только декодер)


        13. контактная информация
        ---------------------- -

        Не стесняйтесь обращаться ко мне с предложениями, проблемами, комментариями, ... касательно
        LodePNG.Если вы столкнулись с изображением PNG, которое не работает должным образом с этим
        декодер, не стесняйтесь отправить его, и я воспользуюсь им, чтобы найти и исправить проблему.

        Мой адрес электронной почты(задайте головоломку имя учетной записи и домен вместе с символом @) :
    Домен: gmail точка com.
        Счет : lode dot vandevenne.


        Авторские права(c) 2005 - 2021 Lode Vandevenne
        * /